

class ['a] army =
	object
		val _soldiers : 'a list = []

		method add sold =
			let rec push_back elt = function
				| [] -> [elt]
				| h::tl -> h::(push_back elt tl)
			in
			{< _soldiers = push_back sold _soldiers >}

		method delete =
			match _soldiers with
			| [] -> {< _soldiers = [] >}
			| h::tl -> {< _soldiers = tl >}

		method print =
			print_string "Printing army : [" ;
			let rec print_rec ind = function
				| [] -> ignore ()
				| h::tl -> if ind <> 0 then print_string ", " ; print_string h#to_string ; print_rec (ind + 1) tl
			in
			print_rec 0 _soldiers ;
			print_endline "]"
	end


class galifrey =
	object (self)
		val _daleks : Dalek.dalek list = []
		val _doctors : Doctor.doctor list = []
		val _people : People.people list = []

        method add_dalek sold =
            let rec push_back elt = function
				| [] -> [elt]
				| h::tl -> h::(push_back elt tl)
			in
            {< _daleks = push_back sold _daleks ; _doctors = _doctors ; _people
            = _people >}

        method add_doctor sold =
            let rec push_back elt = function
				| [] -> [elt]
				| h::tl -> h::(push_back elt tl)
			in
            {< _daleks = _daleks ; _doctors = push_back sold _doctors ; _people
            = _people >}

        method add_people sold =
            let rec push_back elt = function
				| [] -> [elt]
				| h::tl -> h::(push_back elt tl)
			in
            {< _daleks = _daleks ; _doctors = _doctors ; _people = push_back
            sold _people >}

        method delete typ =
            match typ with
            | "dalek" -> {< _daleks = List.tl _daleks ; _doctors = _doctors ;
            _people = _people >}
            | "doctor" -> {< _daleks = _daleks ; _doctors = List.tl _doctors ; _people = _people >}
            | _ -> {< _daleks = _daleks ; _doctors = _doctors ; _people =
                List.tl _people >}

        method private how_many_left = function
            | "dalek" -> List.length _daleks
            | "doctor" -> List.length _doctors
            | _ -> List.length _people

        method make_dalek_talk () =
            if List.length _daleks <= 0 then ignore ()
            else
                let dalek = List.hd _daleks in
                dalek#talk

        method make_doctor_talk () =
            if List.length _doctors <= 0 then ignore ()
            else
                let doctor = List.hd _doctors in
                doctor#talk

        method make_people_talk () =
            if List.length _people <= 0 then ignore ()
            else
                let people = List.hd _people in
                people#talk

        method get_doc () =
            List.hd _doctors

        method get_people () =
            List.hd _people

        method get_dalek () =
            List.hd _daleks

        method make_qulbutoke () =
            print_endline "Qulbutoké !"

        method print_left () =
            print_string "-- Remaining troops :\n" ;
            print_string "Daleks : " ;
            print_int (self#how_many_left "dalek") ;
            print_string "\nDoctors : " ;
            print_int (self#how_many_left "doctor") ;
            print_string "\nPeople : " ;
            print_int (self#how_many_left "people") ;
            print_char '\n'

		method do_time_war =
			print_endline "Get ready for an amazing war experience, featuring useless people, dumb daleks and clueless doctors.\n" ;
            print_endline "Building people's army" ;
            let p1 = (new People.people "Superman") in
            let p2 = (new People.people "Machine gun") in
            let p3 = (new People.people "Qulbutoké") in
            let self = self#add_people p1 in
            let self = self#add_people p2 in
            let self = self#add_people p3 in
            print_endline "Building doctors' army" ;
            let self = self#add_doctor (new Doctor.doctor "Gadget" 32 p1) in
            let self = self#add_doctor (new Doctor.doctor "Hippocrate" 536 p2) in
            let self = self#add_doctor (new Doctor.doctor "Who" 47 p3) in
            print_endline "Building daleks' army" ;
            let self = self#add_dalek (new Dalek.dalek) in
            let self = self#add_dalek (new Dalek.dalek) in
            let self = self#add_dalek (new Dalek.dalek) in
            self#print_left () ;
            self#make_dalek_talk () ;
            self#make_dalek_talk () ;
            self#make_people_talk () ;
            self#make_doctor_talk () ;
            self#make_people_talk () ;
            self#make_doctor_talk () ;
            self#make_dalek_talk () ;
            self#make_dalek_talk () ;
            self#make_dalek_talk () ;
            self#make_doctor_talk () ;
            print_endline "After warm welcome, daleks start attacking..." ;
            let p = self#get_people () in
            let dalek = self#get_dalek () in
            dalek#exterminate p ;
            let self = self#delete "people" in
            let p = self#get_people () in
            dalek#exterminate p ;
            let self = self#delete "people" in
            self#print_left () ;
            print_endline "Only Qulbutoké is remaining !" ;
            self#make_qulbutoke () ;
            self#make_qulbutoke () ;
            self#make_qulbutoke () ;
            self#make_qulbutoke () ;
            self#make_qulbutoke () ;
            self#make_qulbutoke () ;
            self#make_qulbutoke () ;
            print_endline "Doctors start attacking also..." ;
            let p = self#get_people () in
            p#die ;
            let self = self#delete "people" in
            print_endline "Well, he was kind of annoying...\nDaleks and doctors start realising they get along quite well" ;
            self#make_doctor_talk () ;
            print_endline "..." ;
            self#make_doctor_talk () ;
            self#make_dalek_talk () ;
            self#make_dalek_talk () ;
            print_endline "..." ;
            print_endline "Well, they are quite weird but the doctors like them.\nThey end up making a barbecue, telling jokes and eating marshmallows.\nI guess you can say it went well" ;
            self#print_left ()

	end


class people nam =
	object
		val name = nam
		val hp = 100

		initializer print_endline ("People object created with name " ^ nam)

		method to_string = name ^ " : hp=" ^ (string_of_int hp)

		method talk = print_endline ("I'm " ^ name ^ "! Do you know the Doctor?")

		method die = print_endline "Aaaarghh!"
	end


class doctor nam ag (sidekic:People.people) =
	object (self)
		val name = nam
		val age = ag
		val sidekick = sidekic
		val hp = 100

		initializer print_endline ("Object doctor created with name=" ^ nam)

		method to_string = name ^ " : age=" ^ (string_of_int age) ^ " sidekick=(" ^ sidekick#to_string ^ ") hp=" ^ (string_of_int hp)

		method talk = print_endline "Hi! I’m the Doctor!"

		method travel_in_time start arrival =
            print_endline "_______(_@_)_______" ;
            print_endline "| POLICE      BOX |" ;
            print_endline "|_________________|" ;
            print_endline " | _____ | _____ |" ;
            print_endline " | |###| | |###| |" ;
            print_endline " | |###| | |###| |" ;
            print_endline " | _____ | _____ |" ;
            print_endline " | || || | || || |" ;
            print_endline " | ||_|| | ||_|| |" ;
            print_endline " | _____ |$_____ |" ;
            print_endline " | || || | || || |" ;
            print_endline " | ||_|| | ||_|| |" ;
            print_endline " | _____ | _____ |" ;
            print_endline " | || || | || || |" ;
            print_endline " | ||_|| | ||_|| |" ;
            print_endline " |       |       |" ;
            new doctor name (age - (start - arrival)) sidekick

        method use_sonic_screwdriver = print_endline "Whiiiiwhiiiwhiii Whiiiiwhiiiwhiii Whiiiiwhiiiwhiii"

        method private regenerate = new doctor name age sidekick

	end


let () =
    let gal = new Galifrey.galifrey in
    gal#do_time_war


class dalek =
    object (self)
        val name = Random.self_init () ; "Dalek" ^ String.make 1 (char_of_int ((Random.int 95)
        + 32)) ^ String.make 1 (char_of_int ((Random.int 95) + 32)) ^ String.make 1 (char_of_int ((Random.int 95)
        + 32))
        val hp = 100
        val mutable shield = true

        method to_string = name ^ " : hp=" ^ (string_of_int hp) ^ " shield=" ^ (if shield then "true" else "false")

		method talk =
			print_endline (
				match Random.int 4 with
				| 0 -> "Explain! Explain!"
				| 1 -> "Exterminate! Exterminate!"
				| 2 -> "I obey!"
				| _ -> "You are the Doctor! You are the enemy of the Daleks!"
			)

		method exterminate (person:People.people) =
			shield <- shield = false ;
			person#die

		method die =
			print_endline "Emergency Temporal Shift!"

    end


class people nam =
	object
		val name = nam
		val hp = 100

		initializer print_endline ("People object created with name " ^ nam)

		method to_string = name ^ " : hp=" ^ (string_of_int hp)

		method talk = print_endline ("I'm " ^ name ^ "! Do you know the Doctor?")

		method die = print_endline "Aaaarghh!"
	end


let () =
	let obj1 = new People.people "Casimir" in
	let obj2 = new People.people "Hippolyte" in
	print_endline obj1#to_string ;
	print_endline obj2#to_string ;
	obj1#talk ;
	obj2#talk ;
	obj1#die ;
	obj2#die


class people nam =
	object
		val name = nam
		val hp = 100

		initializer print_endline ("People object created with name " ^ nam)

		method to_string = name ^ " : hp=" ^ (string_of_int hp)

		method talk = print_endline ("I'm " ^ name ^ "! Do you know the Doctor?")

		method die = print_endline "Aaaarghh!"
	end


class doctor nam ag (sidekic:People.people) =
	object (self)
		val name = nam
		val age = ag
		val sidekick = sidekic
		val hp = 100

		initializer print_endline ("Object doctor created with name=" ^ nam)

		method to_string = name ^ " : age=" ^ (string_of_int age) ^ " sidekick=(" ^ sidekick#to_string ^ ") hp=" ^ (string_of_int hp)

		method talk = print_endline "Hi! I’m the Doctor!"

		method travel_in_time start arrival =
            print_endline "_______(_@_)_______" ;
            print_endline "| POLICE      BOX |" ;
            print_endline "|_________________|" ;
            print_endline " | _____ | _____ |" ;
            print_endline " | |###| | |###| |" ;
            print_endline " | |###| | |###| |" ;
            print_endline " | _____ | _____ |" ;
            print_endline " | || || | || || |" ;
            print_endline " | ||_|| | ||_|| |" ;
            print_endline " | _____ |$_____ |" ;
            print_endline " | || || | || || |" ;
            print_endline " | ||_|| | ||_|| |" ;
            print_endline " | _____ | _____ |" ;
            print_endline " | || || | || || |" ;
            print_endline " | ||_|| | ||_|| |" ;
            print_endline " |       |       |" ;
            new doctor name (age - (start - arrival)) sidekick

        method use_sonic_screwdriver = print_endline "Whiiiiwhiiiwhiii Whiiiiwhiiiwhiii Whiiiiwhiiiwhiii"

        method private regenerate = new doctor name age sidekick

	end


let () =
    let dalek = new Dalek.dalek in
	let human = new People.people "human" in
	let doctor = new Doctor.doctor "Who" 87 human in
	let doctor = doctor#travel_in_time 2016 1964 in
	print_endline "Introducing contestants : " ;
	print_endline human#to_string ;
	print_endline doctor#to_string ;
	print_endline dalek#to_string ;
	dalek#talk ;
	human#talk ;
	doctor#talk ;
	dalek#talk ;
	dalek#talk ;
	doctor#use_sonic_screwdriver ;
	dalek#talk ;
	dalek#exterminate human ;
	print_endline "\nRemaining contestants : " ;
	print_endline doctor#to_string ;
	print_endline dalek#to_string ;
	dalek#talk ;
	doctor#use_sonic_screwdriver ;
	dalek#die


class dalek =
    object (self)
        val name = Random.self_init () ; "Dalek" ^ String.make 1 (char_of_int ((Random.int 95)
        + 32)) ^ String.make 1 (char_of_int ((Random.int 95) + 32)) ^ String.make 1 (char_of_int ((Random.int 95)
        + 32))
        val hp = 100
        val mutable shield = true

        method to_string = name ^ " : hp=" ^ (string_of_int hp) ^ " shield=" ^ (if shield then "true" else "false")

		method talk =
			print_endline (
				match Random.int 4 with
				| 0 -> "Explain! Explain!"
				| 1 -> "Exterminate! Exterminate!"
				| 2 -> "I obey!"
				| _ -> "You are the Doctor! You are the enemy of the Daleks!"
			)

		method exterminate (person:People.people) =
			shield <- shield = false ;
			person#die

		method die =
			print_endline "Emergency Temporal Shift!"

    end


class ['a] army =
	object
		val _soldiers : 'a list = []

		method add sold =
			let rec push_back elt = function
				| [] -> [elt]
				| h::tl -> h::(push_back elt tl)
			in
			{< _soldiers = push_back sold _soldiers >}

		method delete =
			match _soldiers with
			| [] -> {< _soldiers = [] >}
			| h::tl -> {< _soldiers = tl >}

		method print =
			print_string "Printing army : [" ;
			let rec print_rec ind = function
				| [] -> ignore ()
				| h::tl -> if ind <> 0 then print_string ", " ; print_string h#to_string ; print_rec (ind + 1) tl
			in
			print_rec 0 _soldiers ;
			print_endline "]"
	end


class people nam =
	object
		val name = nam
		val hp = 100

		initializer print_endline ("People object created with name " ^ nam)

		method to_string = name ^ " : hp=" ^ (string_of_int hp)

		method talk = print_endline ("I'm " ^ name ^ "! Do you know the Doctor?")

		method die = print_endline "Aaaarghh!"
	end


class doctor nam ag (sidekic:People.people) =
	object (self)
		val name = nam
		val age = ag
		val sidekick = sidekic
		val hp = 100

		initializer print_endline ("Object doctor created with name=" ^ nam)

		method to_string = name ^ " : age=" ^ (string_of_int age) ^ " sidekick=(" ^ sidekick#to_string ^ ") hp=" ^ (string_of_int hp)

		method talk = print_endline "Hi! I’m the Doctor!"

		method travel_in_time start arrival =
            print_endline "_______(_@_)_______" ;
            print_endline "| POLICE      BOX |" ;
            print_endline "|_________________|" ;
            print_endline " | _____ | _____ |" ;
            print_endline " | |###| | |###| |" ;
            print_endline " | |###| | |###| |" ;
            print_endline " | _____ | _____ |" ;
            print_endline " | || || | || || |" ;
            print_endline " | ||_|| | ||_|| |" ;
            print_endline " | _____ |$_____ |" ;
            print_endline " | || || | || || |" ;
            print_endline " | ||_|| | ||_|| |" ;
            print_endline " | _____ | _____ |" ;
            print_endline " | || || | || || |" ;
            print_endline " | ||_|| | ||_|| |" ;
            print_endline " |       |       |" ;
            new doctor name (age - (start - arrival)) sidekick

        method use_sonic_screwdriver = print_endline "Whiiiiwhiiiwhiii Whiiiiwhiiiwhiii Whiiiiwhiiiwhiii"

        method private regenerate = new doctor name age sidekick

	end


let () =
	let dalek_army = new Army.army in
	let doctor_army = new Army.army in
	let people_army = new Army.army in

	print_endline "--People's army" ;
	print_endline "Adding two people to the people's army" ;
	let people_army = people_army#add (new People.people "dodo") in
	let people_army = people_army#add (new People.people "human") in
	people_army#print ;
	print_endline "Calling remove on the people's army" ;
	let people_army = people_army#delete in
	people_army#print ;
	print_endline "Removing second people" ;
	let people_army = people_army#delete in
	people_army#print ;

	print_endline "\n-- Doctors' army" ;
	print_endline "Adding two doctors to the doctors' army" ;
	let doctor_army = doctor_army#add (new Doctor.doctor "Who" 58 (new People.people "pet1")) in
	let doctor_army = doctor_army#add (new Doctor.doctor "Bean" 36 (new People.people "pet2")) in
	doctor_army#print ;
	print_endline "Calling remove on the doctors' army" ;
	let doctor_army = doctor_army#delete in
	doctor_army#print ;
	print_endline "Removing second doctor" ;
	let doctor_army = doctor_army#delete in
	doctor_army#print ;

	print_endline "\n-- Daleks' army" ;
	print_endline "Adding two daleks to the daleks' army" ;
	let dalek_army = dalek_army#add (new Dalek.dalek) in
	let dalek_army = dalek_army#add (new Dalek.dalek) in
	dalek_army#print ;
	print_endline "Calling remove on the daleks' army" ;
	let dalek_army = dalek_army#delete in
	dalek_army#print ;
	print_endline "Removing second dalek" ;
	let dalek_army = dalek_army#delete in
	dalek_army#print


class dalek =
    object (self)
        val name = Random.self_init () ; "Dalek" ^ String.make 1 (char_of_int ((Random.int 95)
        + 32)) ^ String.make 1 (char_of_int ((Random.int 95) + 32)) ^ String.make 1 (char_of_int ((Random.int 95)
        + 32))
        val hp = 100
        val mutable shield = true

        method to_string = name ^ " : hp=" ^ (string_of_int hp) ^ " shield=" ^ (if shield then "true" else "false")

		method talk =
			print_endline (
				match Random.int 4 with
				| 0 -> "Explain! Explain!"
				| 1 -> "Exterminate! Exterminate!"
				| 2 -> "I obey!"
				| _ -> "You are the Doctor! You are the enemy of the Daleks!"
			)

		method exterminate (person:People.people) =
			shield <- shield = false ;
			person#die

		method die =
			print_endline "Emergency Temporal Shift!"

    end


class people nam =
	object
		val name = nam
		val hp = 100

		initializer print_endline ("People object created with name " ^ nam)

		method to_string = name ^ " : hp=" ^ (string_of_int hp)

		method talk = print_endline ("I'm " ^ name ^ "! Do you know the Doctor?")

		method die = print_endline "Aaaarghh!"
	end


class doctor nam ag (sidekic:People.people) =
	object (self)
		val name = nam
		val age = ag
		val sidekick = sidekic
		val hp = 100

		initializer print_endline ("Object doctor created with name=" ^ nam)

		method to_string = name ^ " : age=" ^ (string_of_int age) ^ " sidekick=(" ^ sidekick#to_string ^ ") hp=" ^ (string_of_int hp)

		method talk = print_endline "Hi! I’m the Doctor!"

		method travel_in_time start arrival =
            print_endline "_______(_@_)_______" ;
            print_endline "| POLICE      BOX |" ;
            print_endline "|_________________|" ;
            print_endline " | _____ | _____ |" ;
            print_endline " | |###| | |###| |" ;
            print_endline " | |###| | |###| |" ;
            print_endline " | _____ | _____ |" ;
            print_endline " | || || | || || |" ;
            print_endline " | ||_|| | ||_|| |" ;
            print_endline " | _____ |$_____ |" ;
            print_endline " | || || | || || |" ;
            print_endline " | ||_|| | ||_|| |" ;
            print_endline " | _____ | _____ |" ;
            print_endline " | || || | || || |" ;
            print_endline " | ||_|| | ||_|| |" ;
            print_endline " |       |       |" ;
            new doctor name (age - (start - arrival)) sidekick

        method use_sonic_screwdriver = print_endline "Whiiiiwhiiiwhiii Whiiiiwhiiiwhiii Whiiiiwhiiiwhiii"

        method private regenerate = new doctor name age sidekick

	end


let () =
    let doctor = new Doctor.doctor "Who" 47 (new People.people "Dalek") in
    print_endline doctor#to_string ;
    print_string "doctor talking : " ;
    doctor#talk ;
    print_string "doctor using screwdriver : " ;
    doctor#use_sonic_screwdriver ;
    print_endline doctor#to_string ;
    print_endline "travelling in time from 2016 to 1980" ;
    let doctor = doctor#travel_in_time 2016 1980 in
    print_endline doctor#to_string ;
    print_endline "travelling in time from 1980 to 2016" ;
    let doctor = doctor#travel_in_time 1980 2016 in
    print_endline doctor#to_string ;
    print_endline "travelling in time from 2016 to 1932" ;
    let doctor = doctor#travel_in_time 2016 1932 in
    print_endline doctor#to_string ;
    print_endline "(I know it makes no sense to have a negative age, but so does traveling back in time don't you think ?)"


type phosphate = string

type deoxyribose = string

type nucleobase = A | T | C | G | U | None

type nucleotide = {
    phos : phosphate ;
    deox : deoxyribose ;
    nucl : nucleobase
}

type helix = nucleotide list

type rna = nucleobase list

type aminoacid = Stop | Ala | Arg | Asn | Asp | Cys | Gln | Glu | Gly | His |
Ile | Leu | Lys | Met | Phe | Pro | Ser | Thr | Trp | Tyr | Val

type protein = aminoacid list

let generate_nucleotide nucl =
    {phos = "phosphate"; deox = "deoxyribose"; nucl =
            match nucl with
                | 'A' -> A
                | 'T' -> T
                | 'C' -> C
                | 'G' -> G
                | 'U' -> U
                | _ -> None
    }

let random_nucl () =
    generate_nucleotide ( match Random.int 4 with
        | 0 -> 'A'
        | 1 -> 'T'
        | 2 -> 'C'
        | 3 -> 'G'
        | _ -> ' ' )

let rec generate_helix n : helix =
    Random.self_init ();
    if n <= 0 then []
    else (random_nucl ()::(generate_helix (n - 1)))

let compl_nucl = function
    | {nucl; _} when nucl = A -> generate_nucleotide 'T'
    | {nucl; _} when nucl = T -> generate_nucleotide 'A'
    | {nucl; _} when nucl = C -> generate_nucleotide 'G'
    | {nucl; _} when nucl = G -> generate_nucleotide 'C'
    | _ -> generate_nucleotide ' '

let rec complementary_helix (hel:helix) : helix =
    match hel with
        | [] -> []
        | nucl::nucls -> (compl_nucl nucl)::(complementary_helix nucls)

let compl_nucleobase = function
    | A -> U
    | T -> A
    | G -> C
    | C -> G
    | _ -> None

let generate_rna (hel:helix) : rna =
    let rec gen_rna = function
        | [] -> []
        | nucl::nucls -> (compl_nucleobase nucl.nucl)::(gen_rna nucls)
    in
    gen_rna hel

let rec generate_bases_triplets (rna:rna) =
    match rna with
        | fst::scd::thrd::rest -> (fst,scd,thrd)::(generate_bases_triplets rest)
        | _ -> []

let decode_arn (rna:rna) : protein =
    let triplets = generate_bases_triplets rna in
    let rec prot_from_triplets triplets =
    match triplets with
        | a::b::c::d::e::f::rest when a = (A,G,A) -> (Arg)::(prot_from_triplets rest)
        | a::b::c::d::e::f::rest when a = (C,U,A) -> (Leu)::(prot_from_triplets rest)
        | a::b::c::d::e::f::rest when a = (U,C,A) -> (Ser)::(prot_from_triplets rest)
        | a::b::c::d::rest when a = (G,C,A) -> (Ala)::(prot_from_triplets rest)
        | a::b::c::d::rest when a = (G,G,A) -> (Gly)::(prot_from_triplets rest)
        | a::b::c::d::rest when a = (C,C,C) -> (Pro)::(prot_from_triplets rest)
        | a::b::c::d::rest when a = (A,C,A) -> (Thr)::(prot_from_triplets rest)
        | a::b::c::d::rest when a = (G,U,A) -> (Val)::(prot_from_triplets rest)
        | a::b::c::rest when a = (U,A,A) -> [Stop]
        | a::b::c::rest when a = (A,U,A) -> (Ile)::(prot_from_triplets rest)
        | a::b::rest when a = (A,A,C) -> (Asn)::(prot_from_triplets rest)
        | a::b::rest when a = (G,A,C) -> (Asp)::(prot_from_triplets rest)
        | a::b::rest when a = (U,G,C) -> (Cys)::(prot_from_triplets rest)
        | a::b::rest when a = (C,A,A) -> (Gln)::(prot_from_triplets rest)
        | a::b::rest when a = (G,A,A) -> (Glu)::(prot_from_triplets rest)
        | a::b::rest when a = (C,A,C) -> (His)::(prot_from_triplets rest)
        | a::b::rest when a = (A,A,A) -> (Lys)::(prot_from_triplets rest)
        | a::b::rest when a = (U,U,C) -> (Phe)::(prot_from_triplets rest)
        | a::b::rest when a = (U,A,C) -> (Tyr)::(prot_from_triplets rest)
        | a::rest when a = (A,U,G) -> (Met)::(prot_from_triplets rest)
        | a::rest when a = (U,G,G) -> (Trp)::(prot_from_triplets rest)
        | _ -> []
    in
    prot_from_triplets triplets



let nucleobase_to_string = function
    | A -> "A"
    | T -> "T"
    | C -> "C"
    | G -> "G"
    | U -> "U"
    | None -> "None"

let nucl_to_string nucl =
    "{\n\tphosphate = " ^
    nucl.phos ^
    "\n\tdeoxyribose = " ^
    nucl.deox ^
    "\n\tnucleobase = " ^
    nucleobase_to_string nucl.nucl ^
    "\n}"

let rec helix_to_string (hel:helix) =
    match hel with
        | [] -> ""
        | nucl::nucls -> let nexts = (helix_to_string nucls) in
                         let fst = (nucl_to_string nucl) in
                         if nexts = "" then fst ^ "\n"
                         else fst ^ "\n  ⇩\n" ^ nexts

let rec print_rna = function
    | [] -> print_string ""
    | nucl::nucls -> 
        begin
            match nucl with
                | A -> print_char 'A'
                | U -> print_char 'U'
                | G -> print_char 'G'
                | C -> print_char 'C'
                | _ -> print_string ""
        end ;
        print_rna nucls

let rec print_triplets = function
    | [] -> print_string "\n"
    | (a,b,c)::rest ->  print_char '(' ; print_string (nucleobase_to_string a) ;
                        print_char ',' ; print_string (nucleobase_to_string b) ;
                        print_char ',' ; print_string (nucleobase_to_string c) ;
                        print_string ")\n" ; print_triplets rest

let string_of_protein (prot:protein) =
    let get_str amino =
        match amino with
        | Stop -> "Stop"
        | Ala -> "Ala"
        | Arg -> "Arg"
        | Asn -> "Asn"
        | Asp -> "Asp"
        | Cys -> "Cys"
        | Gln -> "Gln"
        | Glu -> "Glu"
        | Gly -> "Gly"
        | His -> "His"
        | Ile -> "Ile"
        | Leu -> "Leu"
        | Lys -> "Lys"
        | Met -> "Met"
        | Phe -> "Phe"
        | Pro -> "Pro"
        | Ser -> "Ser"
        | Thr -> "Thr"
        | Trp -> "Trp"
        | Tyr -> "Tyr"
        | Val -> "Val"
    in
    let rec build_prot_str prot n =
        match prot with
            | [] -> ""
            | ami::amis -> (if n <> 0 then ", " else "") ^ (get_str ami) ^
            build_prot_str amis (n + 1)
    in
    "[" ^ build_prot_str prot 0 ^ "]"

let print_testing n =
    let rna = generate_rna (generate_helix n) in
    print_string "RNA (" ;
    print_int n ;
    print_string " nucleobases) : " ;
    print_rna rna ;
    print_char '\n' ;
    print_triplets (generate_bases_triplets rna)

let print_testing_decode n =
    let rna =
        [A;G;A;A;G;G;C;G;A;C;G;C;C;G;G;C;G;U;A;A;C;A;A;U;G;A;C;G;A;U;U;A;A;U;A;G;U;G;A]
    in
    print_string "triplets : \n" ;
    print_triplets (generate_bases_triplets rna) ;
    print_string "\nprotein : " ;
    print_endline (string_of_protein (decode_arn rna))

let rec helix_from_str str ind : helix =
    if ind >= String.length str then []
    else
        (generate_nucleotide (String.get str ind))::(helix_from_str str (ind + 1))

let life str =
    print_string "input : " ;
    print_endline str ;
    let helix = helix_from_str str 0 in
    print_string "helix : " ;
    print_string (helix_to_string helix) ;
    let rna = generate_rna helix in
    print_string "\nrna : " ;
    print_rna rna ;
    let triplets = generate_bases_triplets rna in
    print_string "\n\ntriplets :\n" ;
    print_triplets triplets ;
    print_string "protein : " ;
    print_endline (string_of_protein (decode_arn rna)) ;
    print_char '\n'

let () =
    life "TCTTCCGCTGCGGCCGCATTGTTACTGCTAATTATCACT"


type phosphate = string

type deoxyribose = string

type nucleobase = A | T | C | G | None

type nucleotide = {
    phos : phosphate ;
    deox : deoxyribose ;
    nucl : nucleobase
}

let generate_nucleotide nucl =
    {phos = "phosphate"; deox = "deoxyribose"; nucl =
            match nucl with
                | 'A' -> A
                | 'T' -> T
                | 'C' -> C
                | 'G' -> G
                | _ -> None
    }



let print_nucl nucl =
    print_string "{\n\tphosphate = " ;
    print_string nucl.phos ;
    print_string "\n\tdeoxyribose = " ;
    print_string nucl.deox ;
    print_string "\n\tnucleobase = " ;
    print_string (match nucl.nucl with
        | A -> "A"
        | T -> "T"
        | C -> "C"
        | G -> "G"
        | None -> "None" ) ;
    print_string "\n}"

let print_testing c =
    print_string "testing with : " ;
    print_char c ;
    print_string " : \n" ;
    print_nucl (generate_nucleotide c) ;
    print_char '\n'

let () =
    print_testing 'A' ;
    print_testing 'G' ;
    print_testing 'a' ;
    print_testing ' '


type phosphate = string

type deoxyribose = string

type nucleobase = A | T | C | G | U | None

type nucleotide = {
    phos : phosphate ;
    deox : deoxyribose ;
    nucl : nucleobase
}

type helix = nucleotide list

type rna = nucleobase list

type aminoacid = Stop | Ala | Arg | Asn | Asp | Cys | Gln | Glu | Gly | His |
Ile | Leu | Lys | Met | Phe | Pro | Ser | Thr | Trp | Tyr | Val

type protein = aminoacid list

let generate_nucleotide nucl =
    {phos = "phosphate"; deox = "deoxyribose"; nucl =
            match nucl with
                | 'A' -> A
                | 'T' -> T
                | 'C' -> C
                | 'G' -> G
                | 'U' -> U
                | _ -> None
    }

let random_nucl () =
    generate_nucleotide ( match Random.int 4 with
        | 0 -> 'A'
        | 1 -> 'T'
        | 2 -> 'C'
        | 3 -> 'G'
        | _ -> ' ' )

let rec generate_helix n : helix =
    Random.self_init ();
    if n <= 0 then []
    else (random_nucl ()::(generate_helix (n - 1)))

let compl_nucl = function
    | {nucl; _} when nucl = A -> generate_nucleotide 'T'
    | {nucl; _} when nucl = T -> generate_nucleotide 'A'
    | {nucl; _} when nucl = C -> generate_nucleotide 'G'
    | {nucl; _} when nucl = G -> generate_nucleotide 'C'
    | _ -> generate_nucleotide ' '

let rec complementary_helix (hel:helix) : helix =
    match hel with
        | [] -> []
        | nucl::nucls -> (compl_nucl nucl)::(complementary_helix nucls)

let compl_nucleobase = function
    | A -> U
    | T -> A
    | G -> C
    | C -> G
    | _ -> None

let generate_rna (hel:helix) : rna =
    let rec gen_rna = function
        | [] -> []
        | nucl::nucls -> (compl_nucleobase nucl.nucl)::(gen_rna nucls)
    in
    gen_rna hel

let rec generate_bases_triplets (rna:rna) =
    match rna with
        | fst::scd::thrd::rest -> (fst,scd,thrd)::(generate_bases_triplets rest)
        | _ -> []

let decode_arn (rna:rna) : protein =
    let triplets = generate_bases_triplets rna in
    let rec prot_from_triplets triplets =
    match triplets with
        | a::b::c::d::e::f::rest when a = (A,G,A) -> (Arg)::(prot_from_triplets rest)
        | a::b::c::d::e::f::rest when a = (C,U,A) -> (Leu)::(prot_from_triplets rest)
        | a::b::c::d::e::f::rest when a = (U,C,A) -> (Ser)::(prot_from_triplets rest)
        | a::b::c::d::rest when a = (G,C,A) -> (Ala)::(prot_from_triplets rest)
        | a::b::c::d::rest when a = (G,G,A) -> (Gly)::(prot_from_triplets rest)
        | a::b::c::d::rest when a = (C,C,C) -> (Pro)::(prot_from_triplets rest)
        | a::b::c::d::rest when a = (A,C,A) -> (Thr)::(prot_from_triplets rest)
        | a::b::c::d::rest when a = (G,U,A) -> (Val)::(prot_from_triplets rest)
        | a::b::c::rest when a = (U,A,A) -> [Stop]
        | a::b::c::rest when a = (A,U,A) -> (Ile)::(prot_from_triplets rest)
        | a::b::rest when a = (A,A,C) -> (Asn)::(prot_from_triplets rest)
        | a::b::rest when a = (G,A,C) -> (Asp)::(prot_from_triplets rest)
        | a::b::rest when a = (U,G,C) -> (Cys)::(prot_from_triplets rest)
        | a::b::rest when a = (C,A,A) -> (Gln)::(prot_from_triplets rest)
        | a::b::rest when a = (G,A,A) -> (Glu)::(prot_from_triplets rest)
        | a::b::rest when a = (C,A,C) -> (His)::(prot_from_triplets rest)
        | a::b::rest when a = (A,A,A) -> (Lys)::(prot_from_triplets rest)
        | a::b::rest when a = (U,U,C) -> (Phe)::(prot_from_triplets rest)
        | a::b::rest when a = (U,A,C) -> (Tyr)::(prot_from_triplets rest)
        | a::rest when a = (A,U,G) -> (Met)::(prot_from_triplets rest)
        | a::rest when a = (U,G,G) -> (Trp)::(prot_from_triplets rest)
        | _ -> []
    in
    prot_from_triplets triplets



let nucleobase_to_string = function
    | A -> "A"
    | T -> "T"
    | C -> "C"
    | G -> "G"
    | U -> "U"
    | None -> "None"

let nucl_to_string nucl =
    "{\n\tphosphate = " ^
    nucl.phos ^
    "\n\tdeoxyribose = " ^
    nucl.deox ^
    "\n\tnucleobase = " ^
    nucleobase_to_string nucl.nucl ^
    "\n}"

let rec helix_to_string (hel:helix) =
    match hel with
        | [] -> ""
        | nucl::nucls -> let nexts = (helix_to_string nucls) in
                         let fst = (nucl_to_string nucl) in
                         if nexts = "" then fst ^ "\n"
                         else fst ^ "\n  ⇩\n" ^ nexts

let rec print_rna = function
    | [] -> print_string ""
    | nucl::nucls -> 
        begin
            match nucl with
                | A -> print_char 'A'
                | U -> print_char 'U'
                | G -> print_char 'G'
                | C -> print_char 'C'
                | _ -> print_string ""
        end ;
        print_rna nucls

let rec print_triplets = function
    | [] -> print_string "\n"
    | (a,b,c)::rest ->  print_char '(' ; print_string (nucleobase_to_string a) ;
                        print_char ',' ; print_string (nucleobase_to_string b) ;
                        print_char ',' ; print_string (nucleobase_to_string c) ;
                        print_string ")\n" ; print_triplets rest

let string_of_protein (prot:protein) =
    let get_str amino =
        match amino with
        | Stop -> "Stop"
        | Ala -> "Ala"
        | Arg -> "Arg"
        | Asn -> "Asn"
        | Asp -> "Asp"
        | Cys -> "Cys"
        | Gln -> "Gln"
        | Glu -> "Glu"
        | Gly -> "Gly"
        | His -> "His"
        | Ile -> "Ile"
        | Leu -> "Leu"
        | Lys -> "Lys"
        | Met -> "Met"
        | Phe -> "Phe"
        | Pro -> "Pro"
        | Ser -> "Ser"
        | Thr -> "Thr"
        | Trp -> "Trp"
        | Tyr -> "Tyr"
        | Val -> "Val"
    in
    let rec build_prot_str prot n =
        match prot with
            | [] -> ""
            | ami::amis -> (if n <> 0 then ", " else "") ^ (get_str ami) ^
            build_prot_str amis (n + 1)
    in
    "[" ^ build_prot_str prot 0 ^ "]"

let print_testing n =
    let rna = generate_rna (generate_helix n) in
    print_string "RNA (" ;
    print_int n ;
    print_string " nucleobases) : " ;
    print_rna rna ;
    print_char '\n' ;
    print_triplets (generate_bases_triplets rna)

let print_testing_decode n =
    let rna =
        [A;G;A;A;G;G;C;G;A;C;G;C;C;G;G;C;G;U;A;A;C;A;A;U;G;A;C;G;A;U;U;A;A;U;A;G;U;G;A]
    in
    print_string "triplets : \n" ;
    print_triplets (generate_bases_triplets rna) ;
    print_string "\nprotein : " ;
    print_endline (string_of_protein (decode_arn rna))

let () =
    print_string "-- testing triplets :\n" ;
    print_testing 0 ;
    print_testing 6 ;
    print_testing 7 ;
    print_testing 8 ;
    print_testing 9 ;
    print_string "-- testing decoding :\n" ;
    print_testing_decode () ;


let reverse_list elts =
	let rec rev_list elts acc =
		match elts with
			| [] -> acc
			| x::xs -> rev_list xs (x::acc)
	in
	rev_list elts []

let incr_last res =
	match res with
		| (nb, elt)::xs -> (nb + 1, elt)::xs
		| _ -> res

let add_to_last x res =
	match res with
		| (nb, elt)::xs when elt = x -> true
		| _ -> false

let encode lis =
	let rec enco elts res =
		match elts with
			| [] -> res
			| x::xs when add_to_last x res -> enco xs (incr_last res)
			| x::xs -> enco xs ((1, x)::res)
	in
	reverse_list (enco lis [])

let rec my_print_list = function
	| [] -> print_char '\n'
	| (nb, elt)::xs -> print_int nb ; print_char elt ; my_print_list xs

let print_char_list chars =
	let rec print_chars chars n =
		match chars with
			| [] -> print_string ""
			| c::cs when n <> 0 -> print_string ", '" ; print_char c ; print_char '\'' ; print_chars cs (n + 1)
			| c::cs -> print_char '\'' ; print_char c ; print_char '\'' ; print_chars cs (n + 1)
	in
	print_char '[' ;
	print_chars chars 0 ;
	print_char ']'

let print_testing elts =
	print_string "testing with " ;
	print_char_list elts ;
	print_string " : " ;
	my_print_list (encode elts)

let () =
	print_testing ['a';'a';'a';'a';'b';'b';'b'] ;
	print_testing [] ;
	print_testing ['a'] ;
	print_testing ['a';'b';'c';'d';'a';'b'] ;
	print_testing ['a';'a';'a';'a';'a']


let reverse_list elts =
	let rec rev_list elts acc =
		match elts with
			| [] -> acc
			| x::xs -> rev_list xs (x::acc)
	in
	rev_list elts []

let concat lis1 lis2 =
	let rec conc lis1 lis2 =
		match lis2 with
			| [] -> reverse_list lis1
			| x::xs -> x::(conc lis1 xs)
	in
	reverse_list (conc lis1 (reverse_list lis2))

let rec prefix_char lis car =
	match lis with
		| [] -> []
		| x::xs -> (car::x)::(prefix_char xs car)

let rec gray = function
	| x when x <= 0 -> []
	| 1 -> [['0'];['1']]
	| n -> concat (prefix_char (gray (n - 1)) '0') (prefix_char (reverse_list (gray (n - 1))) '1')





let rec print_chars = function
	| [] -> print_string "" ;
	| c::cs -> print_char c ; print_chars cs

let print_gray n =
	let res = gray n in
	let rec print_gr lis ind =
		match lis with
			| [] -> print_string ""
			| x::xs -> if ind <> 0 then print_char ' ' ; print_chars x ; print_gr xs (ind + 1)
	in
	print_gr res 0

let print_testing n =
	print_string "testing with " ;
	print_int  n ;
	print_string " : " ;
	print_gray n ;
	print_char '\n'

let () =
	print_testing 0 ;
	print_testing 1 ;
	print_testing 2 ;
	print_testing 3 


type phosphate = string

type deoxyribose = string

type nucleobase = A | T | C | G | None

type nucleotide = {
    phos : phosphate ;
    deox : deoxyribose ;
    nucl : nucleobase
}

type helix = nucleotide list

let generate_nucleotide nucl =
    {phos = "phosphate"; deox = "deoxyribose"; nucl =
            match nucl with
                | 'A' -> A
                | 'T' -> T
                | 'C' -> C
                | 'G' -> G
                | _ -> None
    }

let random_nucl () =
    generate_nucleotide ( match Random.int 4 with
        | 0 -> 'A'
        | 1 -> 'T'
        | 2 -> 'C'
        | 3 -> 'G'
        | _ -> ' ' )

let rec generate_helix n : helix =
    Random.self_init ();
    if n <= 0 then []
    else (random_nucl ()::(generate_helix (n - 1)))

let compl_nucl = function
    | {nucl; _} when nucl = A -> generate_nucleotide 'T'
    | {nucl; _} when nucl = T -> generate_nucleotide 'A'
    | {nucl; _} when nucl = C -> generate_nucleotide 'G'
    | {nucl; _} when nucl = G -> generate_nucleotide 'C'
    | _ -> generate_nucleotide ' '

let rec complementary_helix (hel:helix) : helix =
    match hel with
        | [] -> []
        | nucl::nucls -> (compl_nucl nucl)::(complementary_helix nucls)



let nucl_to_string nucl =
    "{\n\tphosphate = " ^
    nucl.phos ^
    "\n\tdeoxyribose = " ^
    nucl.deox ^
    "\n\tnucleobase = " ^
    (match nucl.nucl with
        | A -> "A"
        | T -> "T"
        | C -> "C"
        | G -> "G"
        | None -> "None" ) ^
    "\n}"

let rec helix_to_string (hel:helix) =
    match hel with
        | [] -> ""
        | nucl::nucls -> let nexts = (helix_to_string nucls) in
                         let fst = (nucl_to_string nucl) in
                         if nexts = "" then fst ^ "\n"
                         else fst ^ "\n  ⇩\n" ^ nexts

let print_testing n =
    let ori_helix = generate_helix n in
    let comp_helix = complementary_helix ori_helix in
    print_string " -- testing with " ;
    print_int n ;
    print_string " : \noriginal helix :\n" ;
    print_endline (helix_to_string ori_helix) ;
    print_string "complementary helix :\n" ;
    print_endline (helix_to_string comp_helix)

let () =
    print_testing 0 ;
    print_testing (-1) ;
    print_testing 1 ;
    print_testing 3


let reverse_list elts =
	let rec rev_list elts acc =
		match elts with
			| [] -> acc
			| x::xs -> rev_list xs (x::acc)
	in
	rev_list elts []

let rec ints_to_string = function
	| [] -> ""
	| x::xs -> (string_of_int x) ^ (ints_to_string xs)

let count_ns prev =
	let rec count prev last n acc =
		match prev with
			| [] 	->	if n <> 0 then last::n::acc
						else acc
			| x::xs ->	if n = 0 || x = last
						then count xs x (n + 1) acc
						else count xs x 1 (last::n::acc)
	in
	reverse_list (count prev 0 0 [])

let rec seq = function
	| n when n < 0 -> []
	| 1 -> [1]
	| n ->
		let prev = seq (n - 1) in
		count_ns prev

let sequence n =
	ints_to_string (seq n)

let print_testing n =
	print_string "testing with " ;
	print_int n ;
	print_string " : " ;
	print_endline (sequence n)

let () =
	print_testing (-1) ;
	print_testing 0 ;
	print_testing 1 ;
	print_testing 2 ;
	print_testing 3 ;
	print_testing 4 ;
	print_testing 5 ;
	print_testing 6 ;
	print_testing 7 ;


let rec is_in elt lis =
    match lis with
        | [] -> false
        | x::xs -> x = elt || is_in elt xs

let crossover lis1 lis2 =
    let rec cross lis1 lis2 acc =
        match lis2 with
            | [] -> acc
            | x::xs when is_in x lis1 -> cross lis1 xs (x::acc)
            | x::xs -> cross lis1 xs acc
    in
    cross lis1 lis2 []





let print_bool = function
    | true -> print_string "true"
    | _ -> print_string "false"

let my_print_string x =
    print_char '"' ;
    print_string x ;
    print_char '"'

let print_list_string lis =
    print_char '[' ;
    let rec print_list_rec lis n =
        match lis with
            | x::xs ->
            begin
                if n <> 0 then print_string ", " ;
                my_print_string x ;
                print_list_rec xs (n + 1)
            end
            | _ -> print_string "" ;
    in
    print_list_rec lis 0 ;
    print_char ']'

let print_list_int lis =
    print_char '[' ;
    let rec print_list_rec lis n =
        match lis with
            | x::xs ->
            begin
                if n <> 0 then print_string ", " ;
                print_int x ;
                print_list_rec xs (n + 1)
            end
            | _ -> print_string "" ;
    in
    print_list_rec lis 0 ;
    print_char ']'

let print_list_bool lis =
    print_char '[' ;
    let rec print_list_rec lis n =
        match lis with
            | x::xs ->
            begin
                if n <> 0 then print_string ", " ;
                print_bool x ;
                print_list_rec xs (n + 1)
            end
            | _ -> print_string "" ;
    in
    print_list_rec lis 0 ;
    print_char ']'

let print_testing_string lis1 lis2 =
    print_string "testing with " ;
    print_list_string lis1 ;
    print_string ", " ;
    print_list_string lis2 ;
    print_string " : " ;
    print_list_string (crossover lis1 lis2) ;
    print_char '\n'

let print_testing_int lis1 lis2 =
    print_string "testing with " ;
    print_list_int lis1 ;
    print_string ", " ;
    print_list_int lis2 ;
    print_string " : " ;
    print_list_int (crossover lis1 lis2) ;
    print_char '\n'

let print_testing_bool lis1 lis2 =
    print_string "testing with " ;
    print_list_bool lis1 ;
    print_string ", " ;
    print_list_bool lis2 ;
    print_string " : " ;
    print_list_bool (crossover lis1 lis2) ;
    print_char '\n'

let () =
    print_testing_int [1;2;3;4;5] [3;4;5;6;7] ;
    print_testing_bool [true;true;true] [false;false;false] ;
    print_testing_string ["lol";"un";"peu"] ["un";"grand";"lol"]


type phosphate = string

type deoxyribose = string

type nucleobase = A | T | C | G | U | None

type nucleotide = {
    phos : phosphate ;
    deox : deoxyribose ;
    nucl : nucleobase
}

type helix = nucleotide list

type rna = nucleobase list

let generate_nucleotide nucl =
    {phos = "phosphate"; deox = "deoxyribose"; nucl =
            match nucl with
                | 'A' -> A
                | 'T' -> T
                | 'C' -> C
                | 'G' -> G
                | 'U' -> U
                | _ -> None
    }

let random_nucl () =
    generate_nucleotide ( match Random.int 4 with
        | 0 -> 'A'
        | 1 -> 'T'
        | 2 -> 'C'
        | 3 -> 'G'
        | _ -> ' ' )

let rec generate_helix n : helix =
    Random.self_init ();
    if n <= 0 then []
    else (random_nucl ()::(generate_helix (n - 1)))

let compl_nucl = function
    | {nucl; _} when nucl = A -> generate_nucleotide 'T'
    | {nucl; _} when nucl = T -> generate_nucleotide 'A'
    | {nucl; _} when nucl = C -> generate_nucleotide 'G'
    | {nucl; _} when nucl = G -> generate_nucleotide 'C'
    | _ -> generate_nucleotide ' '

let rec complementary_helix (hel:helix) : helix =
    match hel with
        | [] -> []
        | nucl::nucls -> (compl_nucl nucl)::(complementary_helix nucls)

let compl_nucleobase = function
    | A -> U
    | T -> A
    | G -> C
    | C -> G
    | _ -> None

let generate_rna (hel:helix) : rna =
    let rec gen_rna = function
        | [] -> []
        | nucl::nucls -> (compl_nucleobase nucl.nucl)::(gen_rna nucls)
    in
    gen_rna hel



let nucl_to_string nucl =
    "{\n\tphosphate = " ^
    nucl.phos ^
    "\n\tdeoxyribose = " ^
    nucl.deox ^
    "\n\tnucleobase = " ^
    (match nucl.nucl with
        | A -> "A"
        | T -> "T"
        | C -> "C"
        | G -> "G"
        | U -> "U"
        | None -> "None" ) ^
    "\n}"

let rec helix_to_string (hel:helix) =
    match hel with
        | [] -> ""
        | nucl::nucls -> let nexts = (helix_to_string nucls) in
                         let fst = (nucl_to_string nucl) in
                         if nexts = "" then fst ^ "\n"
                         else fst ^ "\n  ⇩\n" ^ nexts


let rec print_rna = function
    | [] -> print_string ""
    | nucl::nucls -> 
        begin
            match nucl with
                | A -> print_char 'A'
                | U -> print_char 'U'
                | G -> print_char 'G'
                | C -> print_char 'C'
                | _ -> print_string ""
        end ;
        print_rna nucls

let print_testing n =
    let hel = generate_helix n in
    print_string "testing with a helix of " ;
    print_int n ;
    print_string " nucleotides :\nhelix :\n" ;
    print_string (helix_to_string hel) ;
    print_string " --> RNA : " ;
    print_rna (generate_rna hel) ;
    print_char '\n'

let () =
    print_testing 0 ;
    print_testing 6


type 'a tree = Nil | Node of 'a * 'a tree * 'a tree

let is_bst tree =
    let rec iz_bst tree maxi mini take_maxi take_mini =
        match tree with
        | Nil -> true
        | Node (v, Node (v2,_,_),_) when v2 >= v || (take_mini && v2 < mini) -> false
        | Node (v, _, Node (v2,_,_)) when v2 <= v || (take_maxi && v2 > maxi) -> false
        | Node (v, l, r) -> iz_bst l (v - 1) mini true take_mini && iz_bst r
        maxi (v + 1) take_maxi true
    in
    iz_bst tree 0 0 false false

let rec search_bst value = function
    | n when is_bst n = false -> failwith "Not a bst"
    | Nil -> false
    | Node (v, l, r) -> v = value || (value > v && search_bst value r) || (value
    < v && search_bst value l)

let rec height = function
    | Nil -> 0
    | Node (v, l, r) -> 1 + max (height l) (height r)

let rec is_balanced = function
    | Nil -> true
    | Node (v, l, r) -> is_balanced l && is_balanced r && abs (height l - height r) <= 1

let is_avl tree =
    is_bst tree && is_balanced tree

let rec add_avl value = function
    | Nil -> Node (value, Nil, Nil)
    | Node (v, l, r) when v = value -> failwith "Value already in the avl"
    | Node (v, l, r) -> if value < v then Node (v, add_avl value l, r) else Node
                        (v, l, add_avl value r)

let get_right = function
    | Nil -> Nil
    | Node (v, l, r) -> r

let get_left = function
    | Nil -> Nil
    | Node (v, l, r) -> l

let get_val = function
    | Nil -> 0
    | Node (v, l, r) -> v

let right_rotate z =
    let x = get_left z in
    let y = get_left x in
    let x_val = get_val x in
    let z_val = get_val z in
    let x_r = get_right x in
    let z_r = get_right z in
    Node (x_val, y, Node (z_val, x_r, z_r))

let left_rotate z =
    let y = get_right z in
    let x = get_right y in
    let y_val = get_val y in
    let z_val = get_val z in
    let z_l = get_left z in
    let y_l = get_left y in
    Node (y_val, Node (z_val, z_l, y_l), x)

let greatest_node node1 node2 =
	match node1 with
		| Nil -> node2
		| n -> match node2 with
				| Nil -> node1
				| n2 -> if get_val n2 > get_val n then n2
						else n

let left_or_right node value deletion =
    match node with
        | Nil -> Nil
		| Node (v, l, r) when deletion -> greatest_node l r
        | Node (v, l, r) -> if search_bst value l then l else r

let is_on_left node1 node2 =
    get_val node2 = (get_val (get_left node1))

let build_rebalanced_node z value deletion =
    let y = left_or_right z value deletion in
    let x = left_or_right y value deletion in
    if is_on_left z y && is_on_left y x then right_rotate z
    else if is_on_left z y && is_on_left y x = false then let new_tree
        = left_rotate y in let tmp_res = Node (get_val z, new_tree, get_right z) in right_rotate tmp_res
    else if is_on_left z y = false && is_on_left y x = false then left_rotate z
    else if is_on_left z y = false && is_on_left y x then let new_tree
        = right_rotate y in left_rotate (Node (get_val z, get_left z, new_tree))
    else failwith "Error"

let rec rebalance tree value deletion =
    match tree with
        | Nil -> Nil
        | Node (v, l, r) -> 
                if is_balanced l = false then Node (v, rebalance l value deletion, r)
                else if is_balanced r = false then Node (v, l, rebalance r value deletion)
                else
                    build_rebalanced_node tree value deletion

let insert_avl value = function
    | Nil -> Node (value, Nil, Nil)
    | n when is_avl n = false -> failwith "Not an avl"
    | n -> let new_tree = add_avl value n in
               if is_balanced new_tree then new_tree
               else rebalance new_tree value false

let mini_tree a b c =
    min (min a b) c

let rec min_val = function
    | Nil -> 0
    | Node (v, Nil, Nil) -> v
    | Node (v, l, Nil) -> let mini = min_val l in if mini < v then mini else v
    | Node (v, Nil, r) -> let mini = min_val r in if mini < v then mini else v
    | Node (v, l, r) -> let min1 = min_val l in let min2 = min_val r in
    mini_tree v min1 min2

let rec delete_bst value = function
    | n when is_bst n = false -> failwith "Not a bst"
    | Nil -> failwith "Value not in the bst"
    | Node (v, Nil, Nil) when v = value -> Nil
    | Node (v, l, Nil) when v = value -> l
    | Node (v, Nil, r) when v = value -> r
    | Node (v, l, r) when v = value -> let mini = min_val r in Node (mini, l,
    delete_bst mini r)
    | Node (v, l, r) -> if value < v then Node (v, delete_bst value l, r) else
        Node (v, l, delete_bst value r)

let delete_avl value = function
    | Nil -> failwith "Value not in avl"
    | n when is_avl n = false -> failwith "Not an avl"
    | n -> let new_tree = delete_bst value n in
            if is_balanced new_tree then new_tree
            else rebalance new_tree value true



let print_bool = function
    | true -> print_string "true"
    | _ -> print_string "false"

let print_testing tree n =
    print_int n ;
    print_string " ->                search_bst 42 : " ;
    print_bool (search_bst 42 tree) ;
    print_string " ; height : " ;
    print_int (height tree) ;
    print_string " ; left branch of root height : " ;
    print_int (height (get_left tree)) ;
    print_string " ; right branch of root height : " ;
    print_int (height (get_right tree)) ;
    print_string "\n  -- inserting 42 " ;
    let tree = insert_avl 42 tree in
    print_string " ; search_bst 42 : " ;
    print_bool (search_bst 42 tree) ;
    print_string " ; height : " ;
    print_int (height tree) ;
    print_string " ; left branch of root height : " ;
    print_int (height (get_left tree)) ;
    print_string " ; right branch of root height : " ;
    print_int (height (get_right tree)) ;
    print_string "\n  -- inserting 75 " ;
    let tree = insert_avl 75 tree in
    print_string " ; search_bst 75 : " ;
    print_bool (search_bst 75 tree) ;
    print_string " ; height : " ;
    print_int (height tree) ;
    print_string " ; left branch of root height : " ;
    print_int (height (get_left tree)) ;
    print_string " ; right branch of root height : " ;
    print_int (height (get_right tree)) ;
    print_string "\n  -- inserting 95 " ;
    let tree = insert_avl 95 tree in
    print_string " ; search_bst 95 : " ;
    print_bool (search_bst 95 tree) ;
    print_string " ; height : " ;
    print_int (height tree) ;
    print_string " ; left branch of root height : " ;
    print_int (height (get_left tree)) ;
    print_string " ; right branch of root height : " ;
    print_int (height (get_right tree)) ;
    print_string "\n  -- removing  42 " ;
    let tree = delete_avl 42 tree in
    print_string " ; search_bst 42 : " ;
    print_bool (search_bst 42 tree) ;
    print_string " ; height : " ;
    print_int (height tree) ;
    print_string " ; left branch of root height : " ;
    print_int (height (get_left tree)) ;
    print_string " ; right branch of root height : " ;
    print_int (height (get_right tree)) ;
    print_string "\n  -- removing  75 " ;
    let tree = delete_avl 75 tree in
    print_string " ; search_bst 75 : " ;
    print_bool (search_bst 75 tree) ;
    print_string " ; height : " ;
    print_int (height tree) ;
    print_string " ; left branch of root height : " ;
    print_int (height (get_left tree)) ;
    print_string " ; right branch of root height : " ;
    print_int (height (get_right tree)) ;
    print_string "\n  -- removing  95 " ;
    let tree = delete_avl 95 tree in
    print_string " ; search_bst 95 : " ;
    print_bool (search_bst 95 tree) ;
    print_string " ; height : " ;
    print_int (height tree) ;
    print_string " ; left branch of root height : " ;
    print_int (height (get_left tree)) ;
    print_string " ; right branch of root height : " ;
    print_int (height (get_right tree)) ;
    print_string "\n\n"

 
let () =
	Graphics.open_graph " 800x600" ;
    let tree1 = Node (10,
                    ( Node (5,
                        ( Node (3, Nil, Nil)),
                        ( Node (6, Nil, Nil)))
                    ),
                    ( Node (15,
                        ( Node (11, Nil, Nil)),
                        ( Node (16, Nil, Nil)))
                    )
                )
    in
    let tree2 = Nil in
    let tree3 = Node (10,
                    Nil,
                    Node (15, Nil, Nil)
                )
    in
    print_testing tree1 1 ;
    print_testing tree2 2 ;
    print_testing tree3 3


type 'a tree = Nil | Node of 'a * 'a tree * 'a tree

let draw_rectangle x y w h =
	let up_l_x = x - (w / 2) in
	let up_l_y = y - (h / 2) in
	let up_r_x = x + (w / 2) in
	let up_r_y = y - (h / 2) in
	let lo_l_x = x - (w / 2) in
	let lo_l_y = y + (h / 2) in
	let lo_r_x = x + (w / 2) in
	let lo_r_y = y + (h / 2) in
	Graphics.moveto up_l_x up_l_y ;
	Graphics.lineto lo_l_x lo_l_y ;
	Graphics.moveto lo_l_x lo_l_y ;
	Graphics.lineto lo_r_x lo_r_y ;
	Graphics.moveto lo_r_x lo_r_y ;
	Graphics.lineto up_r_x up_r_y ;
	Graphics.moveto up_r_x up_r_y ;
	Graphics.lineto up_l_x up_l_y

let draw_square x y z =
	draw_rectangle x y z z

let draw_line x1 y1 x2 y2 =
	Graphics.moveto x1 y1 ;
	Graphics.lineto x2 y2

let draw_text_in_box text x y =
	draw_rectangle x y 70 50 ;
	Graphics.moveto (x - 15) (y - 5) ;
	Graphics.draw_string text

let draw_tree_node node =
	let rec draw_tree node x y =
		match node with
		| Nil -> draw_text_in_box "Nil" x y
		| Node (value, l, r) ->
			draw_text_in_box value x y ;
			draw_line (x + 35) y (x + 35 + 100) (y + 50) ;
			draw_line (x + 35) y (x + 35 + 100) (y - 50) ;
			draw_tree r (x + 170) (y + 50) ;
			draw_tree l (x + 170) (y - 50)
	in
	draw_tree node 100 300

let () =
	Graphics.open_graph " 800x600" ;
	draw_square 70 70 100 ;
	draw_tree_node (Node ("string", Nil, Nil)) ;
	ignore (read_line ())


let is_lower c =
	c >= 'a' && c <= 'z'

let is_upper c =
	c >= 'A' && c <= 'Z'

let is_letter c =
	is_lower c || is_upper c

let rec add_n_neg c n =
	let c_int = int_of_char c in
	let a_min = int_of_char 'a' in
	let a_maj = int_of_char 'A' in
	if (is_lower c && c_int - n >= a_min) || (is_upper c && c_int - n >= a_maj)
	then char_of_int (c_int - n)
	else
		if is_lower c
		then add_n_neg 'z' ((n - (c_int - a_min)) - 1)
		else add_n_neg 'Z' ((n - (c_int - a_maj)) - 1)

let rec add_n_pos c n =
	let c_int = int_of_char c in
	let z_min = int_of_char 'z' in
	let z_maj = int_of_char 'Z' in
	if (is_lower c && c_int + n <= z_min) || (is_upper c && c_int + n <= z_maj)
	then char_of_int (c_int + n)
	else
		if is_lower c
		then add_n_pos 'a' ((n - (z_min - c_int)) - 1)
		else add_n_pos 'A' ((n - (z_maj - c_int)) - 1)

let ft_rot_n n str =
	let rotate c =
		if is_letter c
		then if n >= 0 then add_n_pos c n
					   else add_n_neg c n
		else c
	in
	String.map rotate str



let rot42 str =
	ft_rot_n 42 str

let caesar n str =
	ft_rot_n n str

let xor key str =
	let xor_key c =
		char_of_int ((int_of_char c) lxor key)
	in
	if key < 0 then str
	else String.map xor_key str

let rec ft_crypt str funcs =
	match funcs with
		| [] -> str
		| func::funcs2 -> ft_crypt (func str) funcs2



let print_testing_rot str =
	print_string "testing rot42 with \"" ;
	print_string str ;
	print_string "\" : " ;
	print_endline (rot42 str)

let print_testing_caesar n str =
	print_string "testing caesar with " ;
	print_int n ;
	print_string ", \"" ;
	print_string str ;
	print_string "\" : " ;
	print_endline (caesar n str)

let print_testing_xor str key =
	print_string "testing xor with key=" ;
	print_int key ;
	print_string " str=\"" ;
	print_string str ;
	print_string "\" : " ;
	print_endline (xor key str)

let crypt_tests () =
	let str1 = "string" in
	let str2 = "uclwt" in
	let funcs1 = [caesar 1; xor 1] in
	let funcs2 = [xor 1; Uncipher.uncaesar 1] in
	print_string "testing crypt with \"" ;
	print_string str1 ;
	print_string "\" and functions [caesar 1; xor 1] : " ;
	print_endline (ft_crypt str1 funcs1) ;
	print_string "testing crypt with \"" ;
	print_string str2 ;
	print_string "\" and functions [xor 1; uncaesar 1] : " ;
	print_endline (ft_crypt str2 funcs2)

let () =
	print_testing_rot "radar" ;
	print_testing_rot "string" ;
	print_testing_rot "salu" ;
	print_testing_rot "" ;
	print_testing_rot "a" ;
	print_testing_rot "bknkb" ;
	print_testing_rot "ckved" ;
	print_testing_caesar 42 "ckved" ;
	print_testing_caesar 1 "string" ;
	print_testing_caesar 0 "string" ;
	print_testing_xor "string" 0 ;
	print_testing_xor "string" 5 ;
	print_testing_xor "vdipq" 5 ;
	crypt_tests () ;
	print_endline "-- uncipher :" ;
	Uncipher.print_testing_rot "radar" ;
	Uncipher.print_testing_rot "string" ;
	Uncipher.print_testing_rot "salu" ;
	Uncipher.print_testing_rot "" ;
	Uncipher.print_testing_rot "a" ;
	Uncipher.print_testing_rot "hqtqh" ;
	Uncipher.print_testing_rot "iqbkj" ;
	Uncipher.print_testing_caesar 42 "iqbkj" ;
	Uncipher.print_testing_caesar 1 "string" ;
	Uncipher.print_testing_caesar 0 "string" ;
	Uncipher.uncrypt_tests ()


let is_lower c =
	c >= 'a' && c <= 'z'

let is_upper c =
	c >= 'A' && c <= 'Z'

let is_letter c =
	is_lower c || is_upper c

let rec add_n_neg c n =
	let c_int = int_of_char c in
	let a_min = int_of_char 'a' in
	let a_maj = int_of_char 'A' in
	if (is_lower c && c_int - n >= a_min) || (is_upper c && c_int - n >= a_maj)
	then char_of_int (c_int - n)
	else
		if is_lower c
		then add_n_neg 'z' ((n - (c_int - a_min)) - 1)
		else add_n_neg 'Z' ((n - (c_int - a_maj)) - 1)

let rec add_n_pos c n =
	let c_int = int_of_char c in
	let z_min = int_of_char 'z' in
	let z_maj = int_of_char 'Z' in
	if (is_lower c && c_int + n <= z_min) || (is_upper c && c_int + n <= z_maj)
	then char_of_int (c_int + n)
	else
		if is_lower c
		then add_n_pos 'a' ((n - (z_min - c_int)) - 1)
		else add_n_pos 'A' ((n - (z_maj - c_int)) - 1)

let ft_rot_n n str =
	let rotate c =
		if is_letter c
		then if n >= 0 then add_n_pos c n
					   else add_n_neg c (-n)
		else c
	in
	String.map rotate str



let unrot42 str =
	ft_rot_n (-42) str

let uncaesar n str =
	ft_rot_n (-n) str

let rec ft_uncrypt str funcs =
	match funcs with
		| [] -> str
		| func::funcs2 -> ft_uncrypt (func str) funcs2


let print_testing_rot str =
	print_string "testing unrot42 with \"" ;
	print_string str ;
	print_string "\" : " ;
	print_endline (unrot42 str)

let print_testing_caesar n str =
	print_string "testing uncaesar with " ;
	print_int n ;
	print_string ", \"" ;
	print_string str ;
	print_string "\" : " ;
	print_endline (uncaesar n str)

let uncrypt_tests () =
	let str1 = "string" in
	let str2 = "string" in
	let funcs1 = [uncaesar 0; uncaesar 1] in
	let funcs2 = [uncaesar 5; uncaesar 2] in
	print_string "testing crypt with \"" ;
	print_string str1 ;
	print_string "\" and functions [uncaesar 0; uncaesar 1] : " ;
	print_endline (ft_uncrypt str1 funcs1) ;
	print_string "testing crypt with \"" ;
	print_string str2 ;
	print_string "\" and functions [uncaesar 5; uncaesar 2] : " ;
	print_endline (ft_uncrypt str2 funcs2)


type 'a tree = Nil | Node of 'a * 'a tree * 'a tree

let is_bst tree =
    let rec iz_bst tree maxi mini take_maxi take_mini =
        match tree with
        | Nil -> true
        | Node (v, Node (v2,_,_),_) when v2 >= v || (take_mini && v2 < mini) -> false
        | Node (v, _, Node (v2,_,_)) when v2 <= v || (take_maxi && v2 > maxi) -> false
        | Node (v, l, r) -> iz_bst l (v - 1) mini true take_mini && iz_bst r
        maxi (v + 1) take_maxi true
    in
    iz_bst tree 0 0 false false

let rec height = function
    | Nil -> 0
    | Node (v, l, r) -> 1 + max (height l) (height r)

let rec is_perfect = function
    | n when is_bst n = false -> false
    | Nil -> true
    | Node (v, Nil, Nil) -> true
    | Node (v, Node (a,b,c), Node (x,y,z)) -> is_perfect (Node (a,b,c)) &&
                is_perfect (Node (x,y,z)) && height (Node (a,b,c)) = height (Node (x,y,z))
    | _ -> false

let rec is_balanced = function
    | Nil -> true
    | Node (v, l, r) -> is_balanced l && is_balanced r && abs (height l - height r) <= 1

let rec search_bst value = function
    | n when is_bst n = false -> failwith "Not a bst"
    | Nil -> false
    | Node (v, l, r) -> v = value || (value > v && search_bst value r) || (value
    < v && search_bst value l)

let rec add_bst value = function
    | n when is_bst n = false -> failwith "Not a bst"
    | Nil -> Node (value, Nil, Nil)
    | Node (v, l, r) when v = value -> failwith "Value already in the bst"
    | Node (v, l, r) -> if value < v then Node (v, add_bst value l, r) else Node
                        (v, l, add_bst value r)

let mini_tree a b c =
    min (min a b) c

let rec min_val = function
    | Nil -> 0
    | Node (v, Nil, Nil) -> v
    | Node (v, l, Nil) -> let mini = min_val l in if mini < v then mini else v
    | Node (v, Nil, r) -> let mini = min_val r in if mini < v then mini else v
    | Node (v, l, r) -> let min1 = min_val l in let min2 = min_val r in
    mini_tree v min1 min2

let rec delete_bst value = function
    | n when is_bst n = false -> failwith "Not a bst"
    | Nil -> failwith "Value not in the bst"
    | Node (v, Nil, Nil) when v = value -> Nil
    | Node (v, l, Nil) when v = value -> l
    | Node (v, Nil, r) when v = value -> r
    | Node (v, l, r) when v = value -> let mini = min_val r in Node (mini, l,
    delete_bst mini r)
    | Node (v, l, r) -> if value < v then Node (v, delete_bst value l, r) else
        Node (v, l, delete_bst value r)




let print_bool = function
    | true -> print_string "true"
    | _ -> print_string "false"

let print_testing tree n =
    print_int n ;
    print_string " -> is_bst : " ;
    print_bool (is_bst tree) ;
    print_string ", is_perfect : " ;
    print_bool (is_perfect tree) ;
    print_string ", is_balanced : " ;
    print_bool (is_balanced tree) ;
    if is_bst tree then (
        print_string ", search_bst 10 : " ;
        print_bool (search_bst 10 tree) 
    ) ;
    print_char '\n'

let print_insert tree n =
    if is_bst tree then
        begin
            print_int n ;
            print_string " -> height : " ;
            print_int (height tree) ;
            print_string " ; search_bst 42 : " ;
            print_bool (search_bst 42 tree) ;
            print_string " ; inserting 42 ; search_bst 42 : " ;
            let new_tree = add_bst 42 tree in
            print_bool (search_bst 42 new_tree) ;
            print_string " ; height : " ;
            print_int (height new_tree) ;
            print_char '\n'
        end
let print_remove tree n =
    if is_bst tree && search_bst 10 tree then
        begin
            print_int n ;
            print_string " -> height : " ;
            print_int (height tree) ;
            print_string " ; search_bst 10 : " ;
            print_bool (search_bst 10 tree) ;
            print_string " ; removing 10 ; search_bst 10 : " ;
            let new_tree = delete_bst 10 tree in
            print_bool (search_bst 10 new_tree) ;
            print_string " ; height : " ;
            print_int (height new_tree) ;
            print_char '\n'
        end

let () =
    let tree1 =
		Node (10, 
			( Node (4,
				( Node (2, Nil, Nil) ),
				( Node (6,
				  	( Node (5, Nil, Nil) ),
					Nil
				))
			)),
			( Node (17,
			  	Nil,
			  	( Node (22, Nil, Nil) )
			))
		)
	in
    let tree2 = Nil in
    let tree3 = Node (10, Nil, Nil) in
    let tree4 = Node (10, Node (5, Nil, Nil), Nil) in
    let tree5 = Node (10, Node (15, Nil, Nil), Nil) in
    let tree6 =
		Node (10, 
			( Node (4,
				( Node (2, Nil, Nil) ),
				( Node (6,
				  	( Node (1, Nil, Nil) ),
					Nil
				))
			)),
			( Node (17,
			  	Nil,
			  	( Node (22, Nil, Nil) )
			))
		)
	in
    let tree7 = Node (10,
                    ( Node (5,
                        ( Node (3, Nil, Nil)),
                        ( Node (6, Nil, Nil)))
                    ),
                    ( Node (15,
                        ( Node (11, Nil, Nil)),
                        ( Node (16, Nil, Nil)))
                    )
                )
    in
    let tree8 = Node (10,
                    ( Node (9,
                        (Node (10, Nil, Nil)),
                        Nil)
                    ),
                    Nil
                )
    in
    print_testing tree1 1 ;
    print_testing tree2 2 ;
    print_testing tree3 3 ;
    print_testing tree4 4 ;
    print_testing tree5 5 ;
    print_testing tree6 6 ;
    print_testing tree7 7 ;
    print_testing tree8 8 ;
    print_string "\n-- insert tests : \n" ;
    print_insert tree1 1 ;
    print_insert tree2 2 ;
    print_insert tree3 3 ;
    print_insert tree4 4 ;
    print_insert tree5 5 ;
    print_insert tree6 6 ;
    print_insert tree7 7 ;
    print_insert tree8 8 ;
    print_string "\n-- remove tests : \n" ;
    print_remove tree1 1 ;
    print_remove tree2 2 ;
    print_remove tree3 3 ;
    print_remove tree4 4 ;
    print_remove tree5 5 ;
    print_remove tree6 6 ;
    print_remove tree7 7 ;
    print_remove tree8 8


type 'a tree = Nil | Node of 'a * 'a tree * 'a tree

let rec size = function
	| Nil -> 0
	| Node (v, l, r) -> 1 + size l + size r

let maxi a b =
	if b > a then b
	else a

let rec height = function
	| Nil -> 0
	| Node (v, l, r) -> (maxi (height l) (height r)) + 1


	

let draw_rectangle x y w h =
	let up_l_x = x - (w / 2) in
	let up_l_y = y - (h / 2) in
	let up_r_x = x + (w / 2) in
	let up_r_y = y - (h / 2) in
	let lo_l_x = x - (w / 2) in
	let lo_l_y = y + (h / 2) in
	let lo_r_x = x + (w / 2) in
	let lo_r_y = y + (h / 2) in
	Graphics.moveto up_l_x up_l_y ;
	Graphics.lineto lo_l_x lo_l_y ;
	Graphics.moveto lo_l_x lo_l_y ;
	Graphics.lineto lo_r_x lo_r_y ;
	Graphics.moveto lo_r_x lo_r_y ;
	Graphics.lineto up_r_x up_r_y ;
	Graphics.moveto up_r_x up_r_y ;
	Graphics.lineto up_l_x up_l_y

let draw_square x y z =
	draw_rectangle x y z z

let draw_line x1 y1 x2 y2 =
	Graphics.moveto x1 y1 ;
	Graphics.lineto x2 y2

let draw_text_in_box text x y =
	draw_rectangle x y 70 30 ;
	Graphics.moveto (x - 15) (y - 5) ;
	Graphics.draw_string text

let draw_tree node =
	let rec draw_tr node x y decal =
		match node with
		| Nil -> draw_text_in_box "Nil" x y
		| Node (value, l, r) ->
			draw_text_in_box value x y ;
			draw_line (x + 35) y (x + 35 + 100) (y + decal) ;
			draw_line (x + 35) y (x + 35 + 100) (y - decal) ;
			draw_tr r (x + 170) (y + decal) (decal / 2) ;
			draw_tr l (x + 170) (y - decal) (decal / 2)
	in
	draw_tr node 50 300 125



let print_testing tree =
	print_string "size of tree : " ;
	print_endline (string_of_int (size tree)) ;
	print_string "height of tree : " ;
	print_endline (string_of_int (height tree)) ;
	draw_tree tree ;
	ignore (read_line () )

let () =
	Graphics.open_graph " 800x600" ;
	let tree =
		Node ("root", 
			( Node ("left1",
				( Node ("left2", Nil, Nil) ),
				( Node ("right2",
				  	( Node ("left3", Nil, Nil) ),
					Nil
				))
			)),
			( Node ("right1",
			  	Nil,
			  	( Node ("right3", Nil, Nil) )
			))
		)
	in
	print_testing tree


let ft_sum ori_f ori_low ori_up =
	let rec msum f low up acc =
		if up < low then nan
		else
			if low = up then acc +. f low
			else msum f (low + 1) up (acc +. f low)
	in
	msum ori_f ori_low ori_up 0.0

let print_testing low up =
	let func i = float_of_int (i * i) in
	begin
		print_string "testing with low=" ;
		print_int low ;
		print_string " ; up=" ;
		print_int up ;
		print_string " : " ;
		print_float (ft_sum func low up) ;
		print_char '\n'
	end

let () =
	print_testing 1 10 ;
	print_testing 10 10 ;
	print_testing 0 0 ;
	print_testing 1 0 ;
	print_testing (-2) 0 ;
	print_testing 4 6


let fibonacci n =
	if n < 0 then -1
	else
		let rec fibo n i fst scd =
			if n <= 1 then n
			else
				if n = i then fst + scd
				else fibo n (i + 1) scd (fst + scd)
		in
		fibo n 2 0 1

let print_testing n =
	print_string "testing with " ;
	print_int n ;
	print_string " : " ;
	print_int (fibonacci n) ;
	print_char '\n'

let () =
	print_testing (-1) ;
	print_testing 0 ;
	print_testing 1 ;
	print_testing 2 ;
	print_testing 3 ;
	print_testing 4 ;
	print_testing 5 ;
	print_testing 6


let rec converges f x n =
	if n < 0 then false
	else
		if n = 0 then x == f x
		else converges f (f x) (n - 1)

let my_print_bool x =
	if x then print_endline "true"
	else print_endline "false"

let () =
	my_print_bool (converges (( * ) 2) 2 5 );
	my_print_bool (converges (fun x -> x / 2) 2 3) ;
	my_print_bool (converges (fun x -> x / 2) 2 2)


let leibniz_pi delta =
	let real_pi = 4.0 *. (atan 1.0) in
	let delta_reached delta acc = (real_pi -. acc >= 0.0 && real_pi -. acc <= delta) || (acc -. real_pi >= 0.0 && acc -. real_pi <= delta) in
	let incr_acc acc i pos =
		let to_add = (1.0 /. (2.0 *. (float_of_int i) +. 1.0)) in
		if pos then acc +. to_add
		else acc -. to_add
	in
	let rec leib delta i acc pos =
		if i <> 0 && delta_reached delta (4.0 *. acc) then i
		else leib delta (i + 1) (incr_acc acc i pos) (not pos)
	in
	leib delta 0 0.0 true

let () =
	print_int (leibniz_pi 0.0000001) ;
	print_char '\n'


let rec repeat_x n =
	if n < 0 then "Error"
	else
		if n = 0 then ""
		else "x" ^ repeat_x (n - 1)

let print_testing n =
	print_string "testing with ";
	print_int n ;
	print_string " : \"" ;
	print_string (repeat_x n) ;
	print_string "\"\n"

let () =
	print_testing 0 ;
	print_testing (-1) ;
	print_testing 1 ;
	print_testing 5


let rec ackermann m n =
	if m < 0 || n < 0 then -1
	else
		if m = 0 then n + 1
		else
			if n = 0 then ackermann (m - 1) 1
			else ackermann (m - 1) (ackermann m (n - 1))

let print_testing m n =
	print_string "testing with " ;
	print_int m ;
	print_string ", " ;
	print_int n ;
	print_string " : " ;
	print_int (ackermann m n) ;
	print_char '\n'

let () =
	print_testing (-1) 7 ;
	print_testing 0 0;
	print_testing 0 (-1) ;
	print_testing 1 1 ;
	print_testing 1 0 ;
	print_testing 0 1 ;
	print_testing 2 3 ;
	print_testing 4 1
	print_testing (-1) (-1) 


let rec hfs_f n =
	if n < 0 then -1
	else
		if n = 0 then 1
		else n - (hfs_m (hfs_f (n - 1)))

and hfs_m n =
	if n < 0 then -1
	else
		if n = 0 then 0
		else n - (hfs_f (hfs_m (n - 1)))

let print_testing n =
	print_string "testing with " ;
	print_int n ;
	print_string " : m = " ;
	print_int (hfs_m n) ;
	print_string " ; f = ";
	print_int (hfs_f n) ;
	print_char '\n'

let () =
	print_testing 0 ;
	print_testing 4 ;
	print_testing (-1) ;


let rec tak x y z =
	if y < x
	then tak (tak (x - 1) y z) (tak (y - 1) z x) (tak (z - 1) x y)
	else z

let print_testing x y z =
	print_string "testing with " ;
	print_int x ;
	print_string ", " ;
	print_int y ;
	print_string ", " ;
	print_int z ;
	print_string " : " ;
	print_int (tak x y z) ;
	print_char '\n'

let () =
	print_testing 1 2 3 ;
	print_testing 5 23 7 ;
	print_testing 9 1 0 ;
	print_testing 1 1 1 ;
	print_testing 0 42 0 ;
	print_testing 23498 98734 98776 ;
	print_testing (-1) (-1) (-1)


let rec repeat_string ?(str="x") n =
	if n < 0 then "Error"
	else
		if n = 0 then ""
		else str ^ (repeat_string ~str:str (n - 1))

let print_testing str n has_str_arg =
	print_string "testing with ";
	print_int n ;
	if has_str_arg
	then print_string " and string \"" ;
		 print_string str ;
		 print_string "\"" ;
	print_string " : \"" ;
	if has_str_arg then print_string (repeat_string ~str:str n)
	else print_string (repeat_string n) ;
	print_string "\"\n"

let () =
	print_testing "" 0 false ;
	print_testing "" (-1) false ;
	print_testing "" 1 false ;
	print_testing "" 5 false ;
	print_testing "abc" 0 true ;
	print_testing "abc" (-1) true ;
	print_testing "abc" 1 true ;
	print_testing "abc" 5 true 


let rec iter f x n =
	if n < 0 then -1
	else
		if n = 0 then x
		else f (iter f x (n - 1))

let print_testing f x n =
	print_string "testing with " ;
	print_int x ;
	print_string ", " ;
	print_int n ;
	print_string " : " ;
	print_int (iter f x n) ;
	print_char '\n'

let () =
	let func = (fun x -> x + 2) in
	begin
		print_testing func 0 0 ;
		print_testing func 0 1 ;
		print_testing func 0 2 ;
		print_testing func (-2) 3
	end ;
	print_char '\n' ;
	let func = (fun x -> x * x) in
	begin
		print_testing func 2 4
	end


type radar = (float array * string)


type categ = String of string | NullPoint
type point = {coords: float array; category: categ}
type counter = {label: string; mutable count: int}

(* ------------------------------------ *)
(* EXAMPLE OF FILE IMPLEMENTATION BELOW *)

let add_to_array arr elt =
    let newArr = Array.make ((Array.length arr) + 1) elt in
    for i = 0 to (Array.length arr) - 1 do
        newArr.(i) <- arr.(i)
    done ;
    newArr

let reverse_list arr =
    let rec rev_list acc = function
        | [] -> acc
        | h::tl -> rev_list (h::acc) tl
    in
    rev_list [] arr

let list_to_array l =
    let rec lta acc = function
        | [] -> acc
        | h::tl -> lta (add_to_array acc h) tl
    in
    lta (Array.make 0 (List.hd l)) l

let reverse_string str =
    let res_str = ref "" in
    for i = 0 to (String.length str) - 1 do
        res_str := (String.make 1 (String.get str i)) ^ !res_str
    done ;
    !res_str

let split_string str car =
    let rec split str car ind acc =
        if ind >= String.length str then acc
        else
            let current_car = String.get str ind in
            let car_as_str = String.make 1 current_car in
            if current_car = car
            then split str car (ind + 1) (""::acc)
            else split str car (ind + 1) ((car_as_str ^ (List.hd acc))::(List.tl acc))
    in list_to_array (split (reverse_string str) car 0 [""])

let convert_radar_line arr =
    let res_floats = ref (Array.make 0 0.0) in
    for i = 0 to (Array.length arr) - 2 do
        try
            res_floats := add_to_array !res_floats (float_of_string arr.(i))
        with | _ -> ignore ()
    done ;
    (!res_floats, arr.((Array.length arr) - 1))

let convert_to_radar csv_lines =
    let res_radars = ref [] in
    for i = (Array.length csv_lines) - 1 downto 0 do
        res_radars := (convert_radar_line (Array.get csv_lines i))::(!res_radars)
    done ;
    !res_radars

let interpret_as_csv lines =
    let res_lines = ref (Array.make 0 (Array.make 0 "string")) in
    for i = 0 to (Array.length lines) - 1 do
        res_lines := (add_to_array !res_lines (split_string (lines.(i)) ','))
    done ;
    !res_lines

let read_lines filename =
    try
        begin
            let tmp_line = ref "string" in
            let res_lines = ref (Array.make 0 "string") in
            let ic = open_in filename in
            while (
                try
                    begin
                        tmp_line := input_line ic ;
                        true
                    end
                with
                | _ -> close_in ic ; false
            ) do
                res_lines := add_to_array !res_lines !tmp_line
            done ;
            !res_lines
        end
    with
    | _ -> Array.make 0 "string"

let print_float_array a =
    print_string "[|" ;
    for i = 0 to (Array.length a) - 1 do
        if i <> 0 then print_string ", " ;
        print_float a.(i) ;
    done ;
    print_string "|]"

let print_string_array a =
    print_string "[|" ;
    for i = 0 to (Array.length a) - 1 do
        if i <> 0 then print_string ", " ;
        print_char '"' ;
        print_string a.(i) ;
        print_char '"'
    done ;
    print_string "|]"

let read_csv filename =
    let lines = read_lines filename in
    let csv_lines = interpret_as_csv lines in
    csv_lines

let print_radar_line line =
    match line with
    | (floats, str) ->
                print_char '(' ;
                print_float_array floats ;
                print_string ", \"" ;
                print_string str ;
                print_string "\")"

let rec list_get lis ind =
    match lis with
    | [] -> failwith "Out of bounds"
    | h::tl -> if ind = 0 then h else list_get tl (ind - 1)

let examples_of_file filename =
    let csv_lines = read_csv filename in
    let radar_lines = convert_to_radar csv_lines in
    radar_lines
    
let print_radars radar_lines =
    for i = 0 to (List.length radar_lines) - 1 do
        print_int (i + 1) ;
        print_string " -> " ;
        print_radar_line (list_get radar_lines i) ;
        print_char '\n'
    done


(* ------------------------------------- *)
(* END OF EXEMPLE OF FILE IMPLEMENTATION *)


let power a b =
    let total = ref 1.0 in
    for i = b downto 1 do
        total := (!total *. a)
    done ;
    !total

let eu_dist a b =
    let total = ref 0.0 in
    for i = 0 to ((Array.length a) - 1) do
        total := !total +. (power ((Array.get a i) -. (Array.get b i)) 2)
    done ;
    sqrt (!total)

let points_distance a b =
	eu_dist a.coords b.coords

let radar_to_point (points, cat) =
	{coords = points ; category = String cat}

let radars_to_points radars =
	let rec rad_to_p = function
		| [] -> []
		| h::tl -> ((radar_to_point h)::(rad_to_p tl))
	in
	rad_to_p radars

let is_null_point = function
	| {coords = _; category = NullPoint} -> true
	| _ -> false

let print_bool = function
	| true -> print_string "true"
	| _ -> print_string "false"

let closer_point point p1 p2 =
	match p2 with
		| p when is_null_point p -> true
		| p2 -> begin
					match p1 with
					| p when is_null_point p -> false
					| p1 -> points_distance point p1 <= points_distance point p2
				end

let insert_point_to_closests p point closests k =
	let ind = ref (k - 1) in
	while !ind >= 0 && closer_point point p closests.(!ind) do
		if !ind <> k - 1 then closests.(!ind + 1) <- closests.(!ind) ;
		closests.(!ind) <- p ;
		ind := !ind - 1 ;
	done

let find_k_closests points point closests k =
	let rec find_clos points point closests k =
		match points with
		| [] -> ignore ()
		| (h::tl) ->
			begin 
				insert_point_to_closests h point closests k ;
				find_clos tl point closests k 
			end
	in
	find_clos points point closests k

let getCateg = function
	| NullPoint -> "Error"
	| String str -> str

let most_frequent_category closests k =
	let rec update_labels closests ind labels =
		let categ = getCateg closests.(ind).category in
		match labels with
		| [] -> [{label = categ ; count = 1}]
		| h::tl when categ = h.label ->
					begin
						h.count <- h.count + 1 ;
						(h::tl)
					end
		| h::tl -> (h::(update_labels closests ind tl))
	in
	let label_cmp lab1 lab2 =
        if lab1.count = lab2.count then (
            if Random.int 2 = 0 then 1 else -1 )
        else compare lab2.count lab1.count
	in
	let rec most_freq closests ind k labels =
		if ind >= k then 
			begin
				let sorted_lab = List.sort label_cmp labels in
				match sorted_lab with
				| h::tl -> h.label
				| _ -> "Error"
			end
		else
			let labels = update_labels closests ind labels in
			most_freq closests (ind + 1) k labels
	in
	most_freq closests 0 k []		

let print_point point ori_point =
    print_string "  Point (categ : \"" ;
    print_string (
        match point.category with
        | String str -> str
        | _ -> "" ) ;
    print_string "\" ; distance : " ;
    print_float (points_distance point ori_point) ;
    print_string ")"

let print_closests closests k ori_point =
    print_endline "Closests points :" ;
    for i = 0 to k - 1 do
        print_point closests.(i) ori_point ;
        print_char '\n'
    done

let k_nn radars radar k print =
	if k <= 0 then ignore () ;
	let null_point = {coords = Array.make 0 0.; category = NullPoint} in
	let points = radars_to_points radars in
	let point = radar_to_point radar in
	let closests = Array.make k null_point in
    find_k_closests points point closests k ;
    if print then
        begin
            print_string (  match point.category with
                    | String str -> "Category of point : \"" ^ str ^ "\"\n"
                    | _ -> "Error\n" ) ;
            print_closests closests k point
        end ;
	let best_cat = most_frequent_category closests k in
    best_cat

let rec remove_n elts n =
    match elts with
    | [] -> []
    | h::tl when n = 0 -> tl
    | h::tl -> remove_n tl (n - 1)

let rec take_n elts n =
    match elts with
    | h::tl when n = 0 -> h
    | h::tl -> take_n tl (n - 1)
    | [] -> failwith "out of bounds"

let print_testing filename n k =
    print_string "\nLaunching test with file \"" ;
    print_string filename ;
    print_string "\", point number " ;
    print_int n ;
    print_string " and k=" ;
    print_int k ;
    print_endline " : \n-----------------------------------------------" ;
    let raw_radars = examples_of_file filename in
	let radars = remove_n raw_radars n in
	let radar = take_n raw_radars n in
    let best_cat = k_nn radars radar k true in
    print_string " -> Found category : \"" ;
    print_string best_cat ;
    print_endline "\""

let get_radar_category = function
    | (arr, str) -> str

let test_error_rate filename k =
    print_string "\nTesting error rate with k=" ;
    print_int k ;
    print_endline " : " ;
    let right = ref 0 in
    let wrong = ref 0 in
    let raw_radars = examples_of_file filename in
    for i = 0 to (List.length raw_radars) - 1 do
        let tmp_rads = remove_n raw_radars i in
        let rad = take_n raw_radars i in
        let rad_cat = get_radar_category rad in
        let cat = k_nn tmp_rads rad k false in
        if rad_cat = cat then right := !right + 1 else wrong := !wrong + 1 ;
    done ;
    print_int (List.length raw_radars) ;
    print_string " tests performed : " ;
    print_int !right ;
    print_string " (" ;
    print_int ((!right * 100) / List.length raw_radars) ;
    print_string "%) right, " ;
    print_int !wrong ;
    print_string " (" ;
    print_int ((!wrong * 100) / List.length raw_radars) ;
    print_endline "%) wrong."

let () =
	let filename1 = "ionosphere.train.csv" in
    let filename2 = "ionosphere.test.csv" in
    print_testing filename1 0 5 ;
    print_testing filename1 3 20 ;
    print_testing filename2 5 3 ;
    test_error_rate filename1 1 ;
    test_error_rate filename1 2 ;
    test_error_rate filename1 5 ;
    test_error_rate filename1 8 ;
    test_error_rate filename1 13 ;
    test_error_rate filename1 20 ;


let sum a b =
    a +. b

let print_testing a b =
    print_string "testing with " ;
    print_float a ;
    print_string " and " ;
    print_float b ;
    print_string " : " ;
    print_float (sum a b) ;
    print_char '\n'

let () =
    print_testing 42.0 42.0 ;
    print_testing 0.0 0.0 ;
    print_testing (-1.0) 0.0 ;
    print_testing 10000000000000000.0 (-2.0) ;
    print_testing (-42.424424242424242424242442424242424242424242424242424242424242424)
        21.424424242424242424242442424242424242424242424242424242424242424


type radar = (float array * string)


type categ = String of string | NullPoint
type point = {coords: float array; category: categ}
type counter = {label: string; mutable count: int}

(* ------------------------------------ *)
(* EXAMPLE OF FILE IMPLEMENTATION BELOW *)

let add_to_array arr elt =
    let newArr = Array.make ((Array.length arr) + 1) elt in
    for i = 0 to (Array.length arr) - 1 do
        newArr.(i) <- arr.(i)
    done ;
    newArr

let reverse_list arr =
    let rec rev_list acc = function
        | [] -> acc
        | h::tl -> rev_list (h::acc) tl
    in
    rev_list [] arr

let list_to_array l =
    let rec lta acc = function
        | [] -> acc
        | h::tl -> lta (add_to_array acc h) tl
    in
    lta (Array.make 0 (List.hd l)) l

let reverse_string str =
    let res_str = ref "" in
    for i = 0 to (String.length str) - 1 do
        res_str := (String.make 1 (String.get str i)) ^ !res_str
    done ;
    !res_str

let split_string str car =
    let rec split str car ind acc =
        if ind >= String.length str then acc
        else
            let current_car = String.get str ind in
            let car_as_str = String.make 1 current_car in
            if current_car = car
            then split str car (ind + 1) (""::acc)
            else split str car (ind + 1) ((car_as_str ^ (List.hd acc))::(List.tl acc))
    in list_to_array (split (reverse_string str) car 0 [""])

let convert_radar_line arr =
    let res_floats = ref (Array.make 0 0.0) in
    for i = 0 to (Array.length arr) - 2 do
        try
            res_floats := add_to_array !res_floats (float_of_string arr.(i))
        with | _ -> ignore ()
    done ;
    (!res_floats, arr.((Array.length arr) - 1))

let convert_to_radar csv_lines =
    let res_radars = ref [] in
    for i = (Array.length csv_lines) - 1 downto 0 do
        res_radars := (convert_radar_line (Array.get csv_lines i))::(!res_radars)
    done ;
    !res_radars

let interpret_as_csv lines =
    let res_lines = ref (Array.make 0 (Array.make 0 "string")) in
    for i = 0 to (Array.length lines) - 1 do
        res_lines := (add_to_array !res_lines (split_string (lines.(i)) ','))
    done ;
    !res_lines

let read_lines filename =
    try
        begin
            let tmp_line = ref "string" in
            let res_lines = ref (Array.make 0 "string") in
            let ic = open_in filename in
            while (
                try
                    begin
                        tmp_line := input_line ic ;
                        true
                    end
                with
                | _ -> close_in ic ; false
            ) do
                res_lines := add_to_array !res_lines !tmp_line
            done ;
            !res_lines
        end
    with
    | _ -> Array.make 0 "string"

let print_float_array a =
    print_string "[|" ;
    for i = 0 to (Array.length a) - 1 do
        if i <> 0 then print_string ", " ;
        print_float a.(i) ;
    done ;
    print_string "|]"

let print_string_array a =
    print_string "[|" ;
    for i = 0 to (Array.length a) - 1 do
        if i <> 0 then print_string ", " ;
        print_char '"' ;
        print_string a.(i) ;
        print_char '"'
    done ;
    print_string "|]"

let read_csv filename =
    let lines = read_lines filename in
    let csv_lines = interpret_as_csv lines in
    csv_lines

let print_radar_line line =
    match line with
    | (floats, str) ->
                print_char '(' ;
                print_float_array floats ;
                print_string ", \"" ;
                print_string str ;
                print_string "\")"

let rec list_get lis ind =
    match lis with
    | [] -> failwith "Out of bounds"
    | h::tl -> if ind = 0 then h else list_get tl (ind - 1)

let examples_of_file filename =
    let csv_lines = read_csv filename in
    let radar_lines = convert_to_radar csv_lines in
    radar_lines
    
let print_radars radar_lines =
    for i = 0 to (List.length radar_lines) - 1 do
        print_int (i + 1) ;
        print_string " -> " ;
        print_radar_line (list_get radar_lines i) ;
        print_char '\n'
    done


(* ------------------------------------- *)
(* END OF EXEMPLE OF FILE IMPLEMENTATION *)


let power a b =
    let total = ref 1.0 in
    for i = b downto 1 do
        total := (!total *. a)
    done ;
    !total

let eu_dist a b =
    let total = ref 0.0 in
    for i = 0 to ((Array.length a) - 1) do
        total := !total +. (power ((Array.get a i) -. (Array.get b i)) 2)
    done ;
    sqrt (!total)

let points_distance a b =
	eu_dist a.coords b.coords

let radar_to_point (points, cat) =
	{coords = points ; category = String cat}

let radars_to_points radars =
	let rec rad_to_p = function
		| [] -> []
		| h::tl -> ((radar_to_point h)::(rad_to_p tl))
	in
	rad_to_p radars

let is_null_point = function
	| {coords = _; category = NullPoint} -> true
	| _ -> false

let print_bool = function
	| true -> print_string "true"
	| _ -> print_string "false"

let closer_point point p1 p2 =
	match p2 with
		| p when is_null_point p -> true
		| p2 -> begin
					match p1 with
					| p when is_null_point p -> false
					| p1 -> points_distance point p1 <= points_distance point p2
				end

let insert_point_to_closests p point closests k =
	let ind = ref (k - 1) in
	while !ind >= 0 && closer_point point p closests.(!ind) do
		if !ind <> k - 1 then closests.(!ind + 1) <- closests.(!ind) ;
		closests.(!ind) <- p ;
		ind := !ind - 1 ;
	done

let find_k_closests points point closests k =
	let rec find_clos points point closests k =
		match points with
		| [] -> ignore ()
		| (h::tl) ->
			begin 
				insert_point_to_closests h point closests k ;
				find_clos tl point closests k 
			end
	in
	find_clos points point closests k

let getCateg = function
	| NullPoint -> "Error"
	| String str -> str

let most_frequent_category closests k =
	let rec update_labels closests ind labels =
		let categ = getCateg closests.(ind).category in
		match labels with
		| [] -> [{label = categ ; count = 1}]
		| h::tl when categ = h.label ->
					begin
						h.count <- h.count + 1 ;
						(h::tl)
					end
		| h::tl -> (h::(update_labels closests ind tl))
	in
	let label_cmp lab1 lab2 =
		compare lab2.count lab1.count
	in
	let rec most_freq closests ind k labels =
		if ind >= k then 
			begin
				let sorted_lab = List.sort label_cmp labels in
				match sorted_lab with
				| h::tl -> h.label
				| _ -> "Error"
			end
		else
			let labels = update_labels closests ind labels in
			most_freq closests (ind + 1) k labels
	in
	most_freq closests 0 k []		

let print_point point ori_point =
    print_string "  Point (categ : \"" ;
    print_string (
        match point.category with
        | String str -> str
        | _ -> "" ) ;
    print_string "\" ; distance : " ;
    print_float (points_distance point ori_point) ;
    print_string ")"

let print_closests closests k ori_point =
    print_endline "Closests points :" ;
    for i = 0 to k - 1 do
        print_point closests.(i) ori_point ;
        print_char '\n'
    done

let k_nn radars radar k print =
	if k <= 0 then ignore () ;
	let null_point = {coords = Array.make 0 0.; category = NullPoint} in
	let points = radars_to_points radars in
	let point = radar_to_point radar in
	let closests = Array.make k null_point in
    find_k_closests points point closests k ;
    if print then
        begin
            print_string (  match point.category with
                    | String str -> "Category of point : \"" ^ str ^ "\"\n"
                    | _ -> "Error\n" ) ;
            print_closests closests k point
        end ;
	let best_cat = most_frequent_category closests k in
    best_cat

let one_nn radars radar =
	k_nn radars radar 1 true

let rec remove_n elts n =
    match elts with
    | [] -> []
    | h::tl when n = 0 -> tl
    | h::tl -> remove_n tl (n - 1)

let rec take_n elts n =
    match elts with
    | h::tl when n = 0 -> h
    | h::tl -> take_n tl (n - 1)
    | [] -> failwith "out of bounds"

let print_testing filename n =
    print_string "\nLaunching test with file \"" ;
    print_string filename ;
    print_string "\" and point number " ;
    print_int n ;
    print_endline " : \n-----------------------------------------------" ;
    let raw_radars = examples_of_file filename in
	let radars = remove_n raw_radars n in
	let radar = take_n raw_radars n in
    let best_cat = one_nn radars radar in
    print_string " -> Found category : \"" ;
    print_string best_cat ;
    print_endline "\""

let get_radar_category = function
    | (arr, str) -> str

let test_error_rate filename =
    print_endline "\nTesting error rate : " ;
    let right = ref 0 in
    let wrong = ref 0 in
    let raw_radars = examples_of_file filename in
    for i = 0 to (List.length raw_radars) - 1 do
        let tmp_rads = remove_n raw_radars i in
        let rad = take_n raw_radars i in
        let rad_cat = get_radar_category rad in
        let cat = k_nn tmp_rads rad 1 false in
        if rad_cat = cat then right := !right + 1 else wrong := !wrong + 1 ;
    done ;
    print_int (List.length raw_radars) ;
    print_string " tests performed : " ;
    print_int !right ;
    print_string " (" ;
    print_int ((!right * 100) / List.length raw_radars) ;
    print_string "%) right, " ;
    print_int !wrong ;
    print_string " (" ;
    print_int ((!wrong * 100) / List.length raw_radars) ;
    print_endline "%) wrong."

let () =
	let filename1 = "ionosphere.train.csv" in
    let filename2 = "ionosphere.test.csv" in
    print_testing filename1 0 ;
    print_testing filename1 3 ;
    print_testing filename2 5 ;
    test_error_rate filename1


let my_sleep () = Unix.sleep 1

let micronap seconds =
    for i = 0 to (seconds - 1) do
        my_sleep ()
    done

let () =
    let args = Sys.argv in
    try let seconds = int_of_string (args.(1)) in
        micronap seconds
    with
        | Invalid_argument _ -> ignore ()
        | Failure _ -> ignore ()
        | _ -> ignore ()


let () =
    Random.self_init () ;
    let jokes = [|"Quel legume va tres vite et rigole dans les virages ? Reponse : le chou marreur";
    "Qui est le frere d'Albert Einstein ? Reponse : Franck";
    "Qu'est-ce qui fait 999 fois \"TIC\" et 1 fois \"TOC\" ? Reponse : Un mille pattes avec une jambe de bois";
    "Comment amuser une blonde toute la journee ? Il faut lui donner une feuille avec la phrase \"Retournez la feuille\" des deux cotes";
    "C'est un gars qui rentre dans un cafe et plouf."|]
    in
    let ind = Random.int 5 in
    print_endline (jokes.(ind))


let power a b =
    let total = ref 1.0 in
    for i = b downto 1 do
        total := (!total *. a)
    done ;
    !total

let eu_dist a b =
    let total = ref 0.0 in
    for i = 0 to ((Array.length a) - 1) do
        total := !total +. (power ((Array.get a i) -. (Array.get b i)) 2)
    done ;
    sqrt (!total)



let print_float_array a =
    print_char '[' ;
    for i = 0 to (Array.length a) - 1 do
        if i <> 0 then print_string ", " ;
        print_float a.(i) ;
    done ;
    print_char ']'

let print_testing a b =
    print_string "testing with " ;
    print_float_array a ;
    print_string " and " ;
    print_float_array b ;
    print_string " : " ;
    print_float (eu_dist a b) ;
    print_char '\n'

let () =
    let a1 = [|0.0; 0.0; 0.0; 0.0; 0.0|] in
    let a2 = [|1.0; 1.0; 1.0; 1.0; 1.0|] in
    let a3 = [|1.0; (-1.0); 1.0; (-1.0); 1.0|] in
    let a4 = [|(-2.0); (-2.0); 0.0; 2.0; 2.0|] in
    print_testing a1 a1 ;
    print_testing a1 a2 ;
    print_testing a1 a3 ;
    print_testing a2 a3 ;
    print_testing a1 a4


let add_to_array arr elt =
    let newArr = Array.make ((Array.length arr) + 1) elt in
    for i = 0 to (Array.length arr) - 1 do
        newArr.(i) <- arr.(i)
    done ;
    newArr

let read_jokes filename =
    try
        begin
            let arr = Array.make 0 "string" in
            let res_arr = ref arr in
            let line_ref = ref "string" in
            let ic = open_in filename in
            while (try
                    begin
                        line_ref := input_line ic ;
                        true
                    end
                  with
                  | _ -> close_in ic ; false ) do
                res_arr := add_to_array !res_arr !line_ref
            done ;
            !res_arr
        end
    with
        | _ -> Array.make 0 "string"

let () =
    try
        begin
            Random.self_init () ;
            let jokes = read_jokes (Sys.argv).(1) in
            if Array.length jokes > 0
            then
                let ind = Random.int (Array.length jokes) in
                print_endline (jokes.(ind))
        end
    with
        _ -> ignore ()


type 'a ft_ref = {mutable value: 'a}

let return elt =
    {value = elt}

let get (ref:'a ft_ref) =
    ref.value

let set (ref:'a ft_ref) elt =
    ref.value <- elt

let bind (ref:'a ft_ref) func =
    func ref.value



let print_bool = function
    | true -> print_string "true"
    | _ -> print_string "false"

let () =
    print_endline "Creating a = ft_ref 42 with return" ;
    print_endline "Creating b = ft_ref 12.0 with return" ;
    let a = return 42 in
    let b = return 12.0 in
    print_string "Asserting that get a = 42 : " ;
    print_bool (get a = 42) ;
    print_string "\nAsserting that get b = 12.0 : " ;
    print_bool (get b = 12.0) ;
    print_string "\nSetting a to 24\nSetting b to 42.42\n" ;
    set a 24 ;
    set b 42.42 ;
    print_string "Asserting that get a = 24 : " ;
    print_bool (get a = 24) ;
    print_string "\nAsserting that get b = 42.42 : " ;
    print_bool (get b = 42.42) ;
    print_string "\nTest the result of get (bind b (fun x -> return (int_of_float x))) = 42 : " ;
    print_bool (get (bind b (fun x -> return (int_of_float x))) = 42) ;
    print_char '\n'


let add_to_array arr elt =
    let newArr = Array.make ((Array.length arr) + 1) elt in
    for i = 0 to (Array.length arr) - 1 do
        newArr.(i) <- arr.(i)
    done ;
    newArr

let reverse_list arr =
    let rec rev_list acc = function
        | [] -> acc
        | h::tl -> rev_list (h::acc) tl
    in
    rev_list [] arr

let list_to_array l =
    let rec lta acc = function
        | [] -> acc
        | h::tl -> lta (add_to_array acc h) tl
    in
    lta (Array.make 0 (List.hd l)) l

let reverse_string str =
    let res_str = ref "" in
    for i = 0 to (String.length str) - 1 do
        res_str := (String.make 1 (String.get str i)) ^ !res_str
    done ;
    !res_str

let split_string str car =
    let rec split str car ind acc =
        if ind >= String.length str then acc
        else
            let current_car = String.get str ind in
            let car_as_str = String.make 1 current_car in
            if current_car = car
            then split str car (ind + 1) (""::acc)
            else split str car (ind + 1) ((car_as_str ^ (List.hd acc))::(List.tl acc))
    in list_to_array (split (reverse_string str) car 0 [""])

let convert_radar_line arr =
    let res_floats = ref (Array.make 0 0.0) in
    for i = 0 to (Array.length arr) - 2 do
        try
            res_floats := add_to_array !res_floats (float_of_string arr.(i))
        with | _ -> ignore ()
    done ;
    (!res_floats, arr.((Array.length arr) - 1))

let convert_to_radar csv_lines =
    let res_radars = ref [] in
    for i = (Array.length csv_lines) - 1 downto 0 do
        res_radars := (convert_radar_line (Array.get csv_lines i))::(!res_radars)
    done ;
    !res_radars

let interpret_as_csv lines =
    let res_lines = ref (Array.make 0 (Array.make 0 "string")) in
    for i = 0 to (Array.length lines) - 1 do
        res_lines := (add_to_array !res_lines (split_string (lines.(i)) ','))
    done ;
    !res_lines

let read_lines filename =
    try
        begin
            let tmp_line = ref "string" in
            let res_lines = ref (Array.make 0 "string") in
            let ic = open_in filename in
            while (
                try
                    begin
                        tmp_line := input_line ic ;
                        true
                    end
                with
                | _ -> close_in ic ; false
            ) do
                res_lines := add_to_array !res_lines !tmp_line
            done ;
            !res_lines
        end
    with
    | _ -> Array.make 0 "string"

let print_float_array a =
    print_string "[|" ;
    for i = 0 to (Array.length a) - 1 do
        if i <> 0 then print_string ", " ;
        print_float a.(i) ;
    done ;
    print_string "|]"

let print_string_array a =
    print_string "[|" ;
    for i = 0 to (Array.length a) - 1 do
        if i <> 0 then print_string ", " ;
        print_char '"' ;
        print_string a.(i) ;
        print_char '"'
    done ;
    print_string "|]"

let read_csv filename =
    let lines = read_lines filename in
    let csv_lines = interpret_as_csv lines in
    csv_lines

let print_radar_line line =
    match line with
    | (floats, str) ->
                print_char '(' ;
                print_float_array floats ;
                print_string ", \"" ;
                print_string str ;
                print_string "\")"

let rec list_get lis ind =
    match lis with
    | [] -> failwith "Out of bounds"
    | h::tl -> if ind = 0 then h else list_get tl (ind - 1)

let examples_of_file filename =
    let csv_lines = read_csv filename in
    let radar_lines = convert_to_radar csv_lines in
    radar_lines
    
let print_radars radar_lines =
    for i = 0 to (List.length radar_lines) - 1 do
        print_int (i + 1) ;
        print_string " -> " ;
        print_radar_line (list_get radar_lines i) ;
        print_char '\n'
    done

let print_testing filename =
    print_string "TESTING WITH \"" ;
    print_string filename ;
    print_endline "\" : \n" ;
    let ex = examples_of_file filename in
    print_radars ex ;
    print_endline "\nEND OF TESTING"

let () =
    print_testing "ionosphere.test_small.csv" ;
    print_testing "lolz" ;
    print_testing ""


let is_lower c =
	c >= 'a' && c <= 'z'

let is_upper c =
	c >= 'A' && c <= 'Z'

let is_letter c =
	is_lower c || is_upper c

let rec add_n c n =
	let c_int = int_of_char c in
	let z_min = int_of_char 'z' in
	let z_maj = int_of_char 'Z' in
	if (is_lower c && c_int + n <= z_min) || (is_upper c && c_int + n <= z_maj)
	then char_of_int (c_int + n)
	else
		if is_lower c
		then add_n 'a' ((n - (z_min - c_int)) - 1)
		else add_n 'A' ((n - (z_maj - c_int)) - 1)

let ft_rot_n n str =
	let rotate c =
		if is_letter c
		then add_n c n
		else c
	in
	String.map rotate str

let print_testing n str =
	print_string "testing with " ;
	print_int n ;
	print_string ", \"" ;
	print_string str ;
	print_string "\" : " ;
	print_string (ft_rot_n n str) ;
	print_char '\n'

let main () =
	print_testing 0 "abcdefghijklmnopqrstuvwxyz" ;
	print_testing 1 "abcdefghijklmnopqrstuvwxyz" ;
	print_testing 26 "abcdefghijklmnopqrstuvwxyz" ;
	print_testing 27 "abcdefghijklmnopqrstuvwxyz" ;
	print_testing 1 "NBzlk qnbjr !" ;
	print_testing 1 "zyOI2EAS67B9ab"

let () = main ()


let print_numbers x y z n =
	if n <> 0 then print_string ", " ;
	print_int x ;
	print_int y ;
	print_int z

let rec print_comb x y z n =
	print_numbers x y z n ;
	if z <> 9
	then print_comb x y (z + 1) (n + 1)
	else
		if y <> 8
		then print_comb x (y + 1) (y + 2) (n + 1)
		else
			if x <> 7
			then print_comb (x + 1) (x + 2) (x + 3) (n + 1)
			else print_string "\n"

let ft_print_comb () =
	print_comb 0 1 2 0

let main () = ft_print_comb ()

let () = main ()


let rec is_palindrome str fst lst =
	if lst <= fst 
	then true
	else
		let fst_car = String.get str fst in
		let lst_car = String.get str lst in
		if fst_car <> lst_car
		then false
		else is_palindrome str (fst + 1) (lst - 1)

let ft_is_palindrome str =
	let ind_last = ((String.length str) - 1) in
	is_palindrome str 0 ind_last

let print_testing str =
	print_string "testing with \"" ;
	print_string str ;
	print_string "\" : " ;
	let to_print =
		if ft_is_palindrome str
		then "true"
		else "false"
	in
	print_string to_print ;
	print_char '\n'

let main () =
	print_testing "bob" ;
	print_testing "" ;
	print_testing "string" ;
	print_testing "radar" ;
	print_testing " ok " ;
	print_testing "beeb"

let () = main ()


let print_number x =
	if x < 10
	then print_char '0' ;
	print_int x

let print_numbers x y n =
	if n <> 0
	then print_char ',' ; print_char ' ' ;
	print_number x ;
	print_char ' ' ;
	print_number y

let rec print_comb2 x y n =
	print_numbers x y n ;
	if y <> 99
	then print_comb2 x (y + 1) (n + 1)
	else
		if x <> 98
		then print_comb2 (x + 1) (x + 2) (n + 1)
		else print_char '\n'

let ft_print_comb2 () =
	print_comb2 0 1 0

let main () =
	ft_print_comb2 ()

let () = main ()


let ft_test_sign x =
	if x < 0
	then print_endline "negative"
	else print_endline "positive"

let print_testing x =
	begin
		print_string "test with ";
		print_int x;
		print_string ": "
	end

let main () =
	begin
		print_testing 42;
		ft_test_sign 42;
		print_testing (-42);
		ft_test_sign (-42);
		print_testing 0;
		ft_test_sign 0;
		print_testing (-1);
		ft_test_sign (-1)
	end

let () = main ()


let rec ft_power x y =
	if y = 0
	then 1
	else x * (ft_power x (y - 1))

let print_testing x y =
	print_string "testing with " ;
	print_int x ;
	print_string ", " ;
	print_int y ;
	print_string " : " ;
	print_int (ft_power x y) ;
	print_char '\n'

let main () =
	print_testing 5 1 ;
	print_testing 5 0 ;
	print_testing 5 2 ;
	print_testing 0 5 ;
	print_testing 1 5 ;
	print_testing 2 5

let () = main ()


let rec print_rev str ind =
	if ind >= 0
	then
		begin
			print_char (String.get str ind) ;
			print_rev str (ind - 1)
		end
	else
		print_char '\n'

let ft_print_rev str =
	print_rev str ((String.length str) - 1)

let print_testing str =
	print_string "testing with \"" ;
	print_string str ;
	print_string "\" : " ;
	ft_print_rev str

let main () =
	print_testing "test1" ;
	print_testing "" ;
	print_testing "\tlolz\t"

let () = main ()


let rec print_letters c =
	let car = char_of_int c in
	let z_int = int_of_char 'z' in
	if c <= z_int
	then
		begin
			print_char car ;
			print_letters (c + 1)
		end
	else
		begin
			print_char '\n'
		end

let ft_print_alphabet () =
	print_letters (int_of_char 'a')

let main () = ft_print_alphabet ()

let () = main ()

let rec ft_countdown x =
	if x <= 0
	then
		begin
			print_int 0 ;
			print_char '\n'
		end
	else
		begin
			print_int x ;
			print_char '\n' ;
			ft_countdown (x - 1)
		end
	
let print_testing x =
	print_string "testing with " ;
	print_int x ;
	print_endline " :"

let main () =
	print_testing 5 ;
	ft_countdown 5 ;
	print_testing 1 ;
	ft_countdown 1 ;
	print_testing (-1) ;
	ft_countdown (-1)

let () = main ()


let rec string_all func str ind =
	if ind < String.length str
	then
		if func (String.get str ind)
		then string_all func str (ind + 1)
		else false
	else true

let ft_string_all func str =
	string_all func str 0

let is_digit c = c >= '0' && c <= '9'

let print_testing str =
	print_string "testing is_digit with \"" ;
	print_string str ;
	print_string "\" : " ;
	if ft_string_all is_digit str
	then print_string "true"
	else print_string "false" ;
	print_char '\n'

let main () =
	print_testing "012345" ;
	print_testing "012a45" ;
	print_testing "01234a" ;
	print_testing ""

let () = main ()


type t = Spade | Heart | Diamond | Club

let all = [Spade; Heart; Diamond; Club]

let toString = function
	| Spade -> "S"
	| Heart -> "H"
	| Diamond -> "D"
	| Club -> "C"

let toStringVerbose = function
	| Spade -> "Spade"
	| Heart -> "Heart"
	| Diamond -> "Diamond"
	| Club -> "Club"


let print_color_list cols =
	let rec print_cols cols func n =
		if n = 0 then print_string "[" ;
		match cols with
			| [] -> print_string "]"
			| col::cols ->
				if n <> 0 then print_string ", " ;
				print_string (func col) ;
				print_cols cols func (n + 1)
	in
	print_cols cols Color.toString 0 ;
	print_char '\n' ;
	print_cols cols Color.toStringVerbose 0 ;
	print_char '\n'

let () =
	print_color_list (Color.all)


module Value =
struct

	type t = T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10 | Jack | Queen | King | As

	let all = [T2;T3;T4;T5;T6;T7;T8;T9;T10;Jack;Queen;King;As]

	let toInt = function
		| T2 -> 1
		| T3 -> 2
		| T4 -> 3
		| T5 -> 4
		| T6 -> 5
		| T7 -> 6
		| T8 -> 7
		| T9 -> 8
		| T10 -> 9
		| Jack -> 10
		| Queen -> 11
		| King -> 12
		| As -> 13

	let toString = function
		| T2 -> "2"
		| T3 -> "3"
		| T4 -> "4"
		| T5 -> "5"
		| T6 -> "6"
		| T7 -> "7"
		| T8 -> "8"
		| T9 -> "9"
		| T10 -> "10"
		| Jack -> "J"
		| Queen -> "Q"
		| King -> "K"
		| As -> "A"

	let toStringVerbose = function
		| T2 -> "2"
		| T3 -> "3"
		| T4 -> "4"
		| T5 -> "5"
		| T6 -> "6"
		| T7 -> "7"
		| T8 -> "8"
		| T9 -> "9"
		| T10 -> "10"
		| Jack -> "Jack"
		| Queen -> "Queen"
		| King -> "King"
		| As -> "As"

    let next = function
	    | T2 -> T3
	    | T3 -> T4
	    | T4 -> T5
	    | T5 -> T6
	    | T6 -> T7
	    | T7 -> T8
	    | T8 -> T9
    	| T9 -> T10
    	| T10 -> Jack
    	| Jack -> Queen
    	| Queen -> King
    	| King -> As
    	| As -> invalid_arg "As has no next card"

    let previous = function
    	| T2 -> invalid_arg "2 has no previous card"
    	| T3 -> T2
    	| T4 -> T3
    	| T5 -> T4
    	| T6 -> T5
    	| T7 -> T6
    	| T8 -> T7
    	| T9 -> T8
    	| T10 -> T9
    	| Jack -> T10
    	| Queen -> Jack
    	| King -> Queen
    	| As -> King

end

module Color =
struct

	type t = Spade | Heart | Diamond | Club

	let all = [Spade; Heart; Diamond; Club]

	let toString = function
		| Spade -> "S"
		| Heart -> "H"
		| Diamond -> "D"
		| Club -> "C"

	let toStringVerbose = function
		| Spade -> "Spade"
		| Heart -> "Heart"
		| Diamond -> "Diamond"
		| Club -> "Club"

end

type t = {color:Color.t; value:Value.t}

let newCard value col =
	{color = col;
	 value = value}

let rec newCardList values color =
	match values with
		| [] -> []
		| value::values -> (newCard value color)::(newCardList values color)

let allSpades = newCardList ( Value.all ) Color.Spade

let allHearts = newCardList ( Value.all ) Color.Heart

let allDiamonds = newCardList ( Value.all ) Color.Diamond

let allClubs = newCardList ( Value.all ) Color.Club

let all =
	let rec get_all = function
		| [] -> []
		| value::values -> (newCard value Color.Spade)::(newCard value Color.Heart)::(newCard value Color.Diamond)::(newCard value Color.Club)::(get_all values)
	in
	get_all (Value.all )

let getValue card =
	card.value

let getColor card =
	card.color

let toString = function
	| {color = col; value = valu} -> ( Value.toString valu ) ^ ( Color.toString col )

let toStringVerbose = function
	| {color = col; value = valu} -> "Card(" ^ (Value.toStringVerbose valu ) ^ ", " ^ ( Color.toStringVerbose col ) ^ ")"

let compare_values val1 val2 =
	let index lis value =
		let rec ind lis value n =
			match lis with
				| [] -> (-1)
				| x::xs when x = value -> n
				| x::xs -> ind xs value (n + 1)
		in
		ind lis value 0
	in
	let ind1 = index (Value.all) val1 in
	let ind2 = index (Value.all) val2 in
	ind1 - ind2

let compare {color = col1; value = val1} {color = col2; value = val2} =
	compare_values val1 val2

let max card1 card2 =
	if compare card1 card2 < 0 then card2
	else card1

let min card1 card2 =
	if compare card1 card2 > 0 then card2
	else card1

let best cards =
	match cards with
		| [] -> invalid_arg "Empty card list"
		| cards ->
			let rec best_cards cards current_best n =
				match cards with
				| [] -> current_best
				| card::cards ->
					let new_best = if n = 0 then card else max current_best card in
					best_cards cards new_best (n + 1)
			in
			best_cards cards {color=Color.Spade;value=Value.T2} 0

let isOf card col =
	match card with
		| {color = card_col;_} -> col = card_col

let isSpade card =
	isOf card Color.Spade

let isHeart card =
	isOf card Color.Heart

let isDiamond card =
	isOf card Color.Diamond

let isClub card =
	isOf card Color.Club

let print_color_list cols =
	let rec print_cols cols func n =
		if n = 0 then print_string "[" ;
		match cols with
			| [] -> print_string "]"
			| col::cols ->
				if n <> 0 then print_string ", " ;
				print_string (func col) ;
				print_cols cols func (n + 1)
	in
	print_cols cols Card.Color.toString 0 ;
	print_char '\n' ;
	print_cols cols Card.Color.toStringVerbose 0 ;
	print_char '\n'

let color_test () =
	print_color_list (Card.Color.all)

let print_card_list cards func =
	let rec print_cards cards func n =
		if n = 0 then print_string "[" ;
		match cards with
			| [] -> print_string "]"
			| card::cards ->
				if n <> 0 then print_string ", " ;
				print_string (func card) ;
				print_cards cards func (n + 1)
	in
	print_cards cards func 0

let rm_first = function
	| [] -> []
	| x::xs -> xs

let rec rm_last = function
	| [] -> []
	| x::xs when xs = [] -> []
	| x::xs -> x::(rm_last xs)

let rec get_nexts = function
	| [] -> []
	| card::cards -> (Card.Value.next card)::(get_nexts cards)

let rec get_previous = function
	| [] -> []
	| card::cards -> (Card.Value.previous card)::(get_previous cards)

let value_test () =
	let nexts = get_nexts (rm_last (Card.Value.all)) in
	let previous = get_previous (rm_first (Card.Value.all)) in
	print_string "all cards : " ;
	print_card_list (Card.Value.all) Card.Value.toString ;
	print_string "\nall cards verbose : " ;
	print_card_list (Card.Value.all) Card.Value.toStringVerbose ;
	print_string "\nall valid nexts : " ;
	print_card_list nexts Card.Value.toString ;
	print_string "\nall valid previous : " ;
	print_card_list previous Card.Value.toString ;
	print_char '\n'

let print_bool = function
    | true -> "true"
    | _ -> "false"

let card_test () =
    let color1 = Card.Color.Spade in
    let value1 = Card.Value.King in
    let card1 = Card.newCard value1 color1 in
    let color2 = Card.Color.Heart in
    let value2 = Card.Value.Queen in
    let card2 = Card.newCard value2 color2 in
    let color3 = Card.Color.Diamond in
    let value3 = Card.Value.King in
    let card3 = Card.newCard value3 color3 in
    print_string ("building card from color " ^ (Card.Color.toStringVerbose
    color1) ^ " and value " ^ (Card.Value.toStringVerbose value1) ^ " : " ^
    (Card.toStringVerbose card1)) ;
    print_char '\n' ;
    print_string "all spades : " ;
    print_card_list (Card.allSpades ) Card.toStringVerbose ;
    print_char '\n' ;
    print_string "all hearts : " ;
    print_card_list (Card.allHearts ) Card.toStringVerbose ;
    print_char '\n' ;
    print_string "all diamonds : " ;
    print_card_list (Card.allDiamonds ) Card.toStringVerbose ;
    print_char '\n' ;
    print_string "all clubs : " ;
    print_card_list (Card.allClubs ) Card.toStringVerbose ;
    print_char '\n' ;
    print_string "\nall cards : " ;
    print_card_list (Card.all ) Card.toString ;
    print_string ("\n\ngetValue of " ^ (Card.toString card1) ^ " : " ^
    (Card.Value.toStringVerbose (Card.getValue card1))) ;
    print_char '\n' ;
    print_string ("getColor of " ^ (Card.toString card1) ^ " : " ^
    (Card.Color.toStringVerbose (Card.getColor card1))) ;
    print_char '\n' ;
    print_string "\n-- comparision tests : \n" ;
    print_endline ("card1 : " ^ (Card.toStringVerbose card1) ^ " ; card2 : " ^
    (Card.toStringVerbose card2) ^ " ; card3 : " ^ (Card.toStringVerbose card3)) ;
    print_string "compare card1 card2 : " ;
    print_int (Card.compare card1 card2) ;
    print_char '\n' ;
    print_string "compare card2 card1 : " ;
    print_int (Card.compare card2 card1) ;
    print_char '\n' ;
    print_string "compare card1 card3 : " ;
    print_int (Card.compare card1 card3) ;
    print_char '\n' ;
    print_string "max card1 card2 : " ;
    print_endline (if Card.max card1 card2 = card1 then "card1" else "card2") ;
    print_string "max card2 card1 : " ;
    print_endline (if Card.max card2 card1 = card1 then "card1" else "card2") ;
    print_string "max card1 card3 : " ;
    print_endline (if Card.max card1 card3 = card1 then "card1" else "card3") ;
    print_string "max card3 card1 : " ;
    print_endline (if Card.max card3 card1 = card1 then "card1" else "card3") ;
    print_string "min card1 card2 : " ;
    print_endline (if Card.min card1 card2 = card1 then "card1" else "card2") ;
    print_string "min card2 card1 : " ;
    print_endline (if Card.min card2 card1 = card1 then "card1" else "card2") ;
    print_string "min card1 card3 : " ;
    print_endline (if Card.min card1 card3 = card1 then "card1" else "card3") ;
    print_string "min card3 card1 : " ;
    print_endline (if Card.min card3 card1 = card1 then "card1" else "card3") ;
    print_string "best of [card1;card2;card3] : " ;
    print_endline (let best = Card.best [card1;card2;card3] in if best = card1
    then "card1" else if best = card2 then "card2" else "card3") ;
    print_string "best of [card2;card3;card1] : " ;
    print_endline (let best = Card.best [card2;card3;card1] in if best = card1
    then "card1" else if best = card2 then "card2" else "card3") ;
    print_endline ("\ncard1 -> isOf Spade : " ^ (print_bool (Card.isOf
    card1 Card.Color.Spade)) ^ " ; isSpade : " ^ (print_bool (Card.isSpade card1)) ^ " ; isHeart : " ^ (print_bool (Card.isHeart card1)) ^ " ; isDiamond : " ^ (print_bool
    (Card.isDiamond card1)) ^ " ; isClub : " ^ (print_bool (Card.isClub card1)))
    ;
    print_endline ("card2 -> isOf Spade : " ^ (print_bool (Card.isOf
    card2 Card.Color.Spade)) ^ " ; isSpade : " ^ (print_bool (Card.isSpade card2)) ^ " ; isHeart : " ^ (print_bool (Card.isHeart card2)) ^ " ; isDiamond : " ^ (print_bool
    (Card.isDiamond card2)) ^ " ; isClub : " ^ (print_bool (Card.isClub card2)))
    ;
    print_endline ("card3 -> isOf Spade : " ^ (print_bool (Card.isOf
    card3 Card.Color.Spade)) ^ " ; isSpade : " ^ (print_bool (Card.isSpade card3)) ^ " ; isHeart : " ^ (print_bool (Card.isHeart card3)) ^ " ; isDiamond : " ^ (print_bool
    (Card.isDiamond card3)) ^ " ; isClub : " ^ (print_bool (Card.isClub card3)))

let () =
    print_string "-- Card.Color test : \n" ;
    color_test () ;
    print_string "\n-- Card.Value test : \n" ;
    value_test () ;
    print_string "\n-- Card module test : \n" ;
    card_test ()



module Card =
struct

    module Value =
    struct

    	type t = T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10 | Jack | Queen | King | As

    	let all = [T2;T3;T4;T5;T6;T7;T8;T9;T10;Jack;Queen;King;As]

    	let toInt = function
    		| T2 -> 1
    		| T3 -> 2
    		| T4 -> 3
    		| T5 -> 4
    		| T6 -> 5
    		| T7 -> 6
    		| T8 -> 7
    		| T9 -> 8
    		| T10 -> 9
    		| Jack -> 10
    		| Queen -> 11
    		| King -> 12
    		| As -> 13

    	let toString = function
    		| T2 -> "2"
    		| T3 -> "3"
    		| T4 -> "4"
    		| T5 -> "5"
    		| T6 -> "6"
    		| T7 -> "7"
    		| T8 -> "8"
    		| T9 -> "9"
    		| T10 -> "10"
    		| Jack -> "J"
    		| Queen -> "Q"
    		| King -> "K"
    		| As -> "A"
    
    	let toStringVerbose = function
    		| T2 -> "2"
    		| T3 -> "3"
    		| T4 -> "4"
    		| T5 -> "5"
    		| T6 -> "6"
    		| T7 -> "7"
    		| T8 -> "8"
    		| T9 -> "9"
    		| T10 -> "10"
    		| Jack -> "Jack"
    		| Queen -> "Queen"
    		| King -> "King"
    		| As -> "As"

        let next = function
    	    | T2 -> T3
    	    | T3 -> T4
    	    | T4 -> T5
    	    | T5 -> T6
    	    | T6 -> T7
    	    | T7 -> T8
    	    | T8 -> T9
           	| T9 -> T10
        	| T10 -> Jack
        	| Jack -> Queen
        	| Queen -> King
        	| King -> As
        	| As -> invalid_arg "As has no next card"

        let previous = function
        	| T2 -> invalid_arg "2 has no previous card"
        	| T3 -> T2
        	| T4 -> T3
           	| T5 -> T4
        	| T6 -> T5
        	| T7 -> T6
           	| T8 -> T7
        	| T9 -> T8
        	| T10 -> T9
          	| Jack -> T10
          	| Queen -> Jack
        	| King -> Queen
        	| As -> King

    end

    module Color =
    struct

    	type t = Spade | Heart | Diamond | Club

    	let all = [Spade; Heart; Diamond; Club]
    
    	let toString = function
    		| Spade -> "S"
       		| Heart -> "H"
    		| Diamond -> "D"
    		| Club -> "C"

    	let toStringVerbose = function
    		| Spade -> "Spade"
    		| Heart -> "Heart"
    		| Diamond -> "Diamond"
    		| Club -> "Club"

    end

    type t = {color:Color.t; value:Value.t}

    let newCard value col =
	    {color = col;
	    value = value}

    let rec newCardList values color =
    	match values with
    		| [] -> []
    		| value::values -> (newCard value color)::(newCardList values color)

    let allSpades =
    	newCardList ( Value.all ) Color.Spade

    let allHearts =
    	newCardList ( Value.all ) Color.Heart

    let allDiamonds =
    	newCardList ( Value.all ) Color.Diamond

    let allClubs =
    	newCardList ( Value.all ) Color.Club

    let all =
    	let rec get_all = function
    		| [] -> []
    		| value::values -> (newCard value Color.Spade)::(newCard value Color.Heart)::(newCard value Color.Diamond)::(newCard value Color.Club)::(get_all values)
    	in
    	get_all (Value.all )

    let getValue card =
    	card.value

    let getColor card =
    	card.color

    let toString = function
    	| {color = col; value = valu} -> ( Value.toString valu ) ^ ( Color.toString col )

    let toStringVerbose = function
    	| {color = col; value = valu} -> "Card(" ^ (Value.toStringVerbose valu ) ^ ", " ^ ( Color.toStringVerbose col ) ^ ")"

    let compare_values val1 val2 =
    	let index lis value =
    		let rec ind lis value n =
    			match lis with
    				| [] -> (-1)
    				| x::xs when x = value -> n
    				| x::xs -> ind xs value (n + 1)
    		in
    		ind lis value 0
    	in
    	let ind1 = index (Value.all ) val1 in
    	let ind2 = index (Value.all ) val2 in
    	ind1 - ind2

    let compare {color = col1; value = val1} {color = col2; value = val2} =
    	compare_values val1 val2

    let max card1 card2 =
    	if compare card1 card2 < 0 then card2
    	else card1

    let min card1 card2 =
    	if compare card1 card2 > 0 then card2
    	else card1

    let best cards =
    	match cards with
    		| [] -> invalid_arg "Empty card list"
    		| cards ->
    			let rec best_cards cards current_best n =
    				match cards with
    				| [] -> current_best
    				| card::cards ->
    					let new_best = if n = 0 then card else max current_best card in
    					best_cards cards new_best (n + 1)
    			in
    			best_cards cards {color=Color.Spade;value=Value.T2} 0

    let isOf card col =
    	match card with
    		| {color = card_col;_} -> col = card_col

    let isSpade card =
    	isOf card Color.Spade

    let isHeart card =
    	isOf card Color.Heart

    let isDiamond card =
    	isOf card Color.Diamond

    let isClub card =
    	isOf card Color.Club

end

type t = Card.t list

let newDeck () =
    let rec remove_ind elts ind =
        match elts with
            | [] -> []
            | elt::elts when ind = 0 -> elts
            | elt::elts -> elt::(remove_ind elts (ind - 1))
    in
    let rec take_rand_card cards n =
        match cards with
            | [] -> []
            | cards ->
                    let ind = Random.int n in
                    (List.nth cards ind)::(take_rand_card (remove_ind cards ind) (n - 1))
     in
     Random.self_init () ;
     take_rand_card (Card.all ) 52

let toStringList (deck:t) =
    let rec toStr = function
        | [] -> []
        | card::cards -> (Card.toString card)::(toStr cards)
    in
    toStr deck

let toStringListVerbose (deck:t) =
    let rec toStr = function
        | [] -> []
        | card::cards -> (Card.toStringVerbose card)::(toStr cards)
    in
    toStr deck

let drawCard = function
    | [] -> raise (Failure "drawCard : empty list")
    | card::cards -> (card, cards)

let print_color_list cols =
	let rec print_cols cols func n =
		if n = 0 then print_string "[" ;
		match cols with
			| [] -> print_string "]"
			| col::cols ->
				if n <> 0 then print_string ", " ;
				print_string (func col) ;
				print_cols cols func (n + 1)
	in
	print_cols cols Deck.Card.Color.toString 0 ;
	print_char '\n' ;
	print_cols cols Deck.Card.Color.toStringVerbose 0 ;
	print_char '\n'

let color_test () =
	print_color_list (Deck.Card.Color.all)

let print_card_list cards func =
	let rec print_cards cards func n =
		if n = 0 then print_string "[" ;
		match cards with
			| [] -> print_string "]"
			| card::cards ->
				if n <> 0 then print_string ", " ;
				print_string (func card) ;
				print_cards cards func (n + 1)
	in
	print_cards cards func 0

let rm_first = function
	| [] -> []
	| x::xs -> xs

let rec rm_last = function
	| [] -> []
	| x::xs when xs = [] -> []
	| x::xs -> x::(rm_last xs)

let rec get_nexts = function
	| [] -> []
	| card::cards -> (Deck.Card.Value.next card)::(get_nexts cards)

let rec get_previous = function
	| [] -> []
	| card::cards -> (Deck.Card.Value.previous card)::(get_previous cards)

let value_test () =
	let nexts = get_nexts (rm_last (Deck.Card.Value.all)) in
	let previous = get_previous (rm_first (Deck.Card.Value.all)) in
	print_string "all cards : " ;
	print_card_list (Deck.Card.Value.all) Deck.Card.Value.toString ;
	print_string "\nall cards verbose : " ;
	print_card_list (Deck.Card.Value.all) Deck.Card.Value.toStringVerbose ;
	print_string "\nall valid nexts : " ;
	print_card_list nexts Deck.Card.Value.toString ;
	print_string "\nall valid previous : " ;
	print_card_list previous Deck.Card.Value.toString ;
	print_char '\n'

let print_bool = function
    | true -> "true"
    | _ -> "false"

let card_test () =
    let color1 = Deck.Card.Color.Spade in
    let value1 = Deck.Card.Value.King in
    let card1 = Deck.Card.newCard value1 color1 in
    let color2 = Deck.Card.Color.Heart in
    let value2 = Deck.Card.Value.Queen in
    let card2 = Deck.Card.newCard value2 color2 in
    let color3 = Deck.Card.Color.Diamond in
    let value3 = Deck.Card.Value.King in
    let card3 = Deck.Card.newCard value3 color3 in
    print_string ("building card from color " ^ (Deck.Card.Color.toStringVerbose
    color1) ^ " and value " ^ (Deck.Card.Value.toStringVerbose value1) ^ " : " ^
    (Deck.Card.toStringVerbose card1)) ;
    print_char '\n' ;
    print_string "all spades : " ;
    print_card_list (Deck.Card.allSpades ) Deck.Card.toStringVerbose ;
    print_char '\n' ;
    print_string "all hearts : " ;
    print_card_list (Deck.Card.allHearts ) Deck.Card.toStringVerbose ;
    print_char '\n' ;
    print_string "all diamonds : " ;
    print_card_list (Deck.Card.allDiamonds ) Deck.Card.toStringVerbose ;
    print_char '\n' ;
    print_string "all clubs : " ;
    print_card_list (Deck.Card.allClubs ) Deck.Card.toStringVerbose ;
    print_char '\n' ;
    print_string "\nall cards : " ;
    print_card_list (Deck.Card.all ) Deck.Card.toString ;
    print_string ("\n\ngetValue of " ^ (Deck.Card.toString card1) ^ " : " ^
    (Deck.Card.Value.toStringVerbose (Deck.Card.getValue card1))) ;
    print_char '\n' ;
    print_string ("getColor of " ^ (Deck.Card.toString card1) ^ " : " ^
    (Deck.Card.Color.toStringVerbose (Deck.Card.getColor card1))) ;
    print_char '\n' ;
    print_string "\n-- comparision tests : \n" ;
    print_endline ("card1 : " ^ (Deck.Card.toStringVerbose card1) ^ " ; card2 : " ^
    (Deck.Card.toStringVerbose card2) ^ " ; card3 : " ^ (Deck.Card.toStringVerbose card3)) ;
    print_string "compare card1 card2 : " ;
    print_int (Deck.Card.compare card1 card2) ;
    print_char '\n' ;
    print_string "compare card2 card1 : " ;
    print_int (Deck.Card.compare card2 card1) ;
    print_char '\n' ;
    print_string "compare card1 card3 : " ;
    print_int (Deck.Card.compare card1 card3) ;
    print_char '\n' ;
    print_string "max card1 card2 : " ;
    print_endline (if Deck.Card.max card1 card2 = card1 then "card1" else "card2") ;
    print_string "max card2 card1 : " ;
    print_endline (if Deck.Card.max card2 card1 = card1 then "card1" else "card2") ;
    print_string "max card1 card3 : " ;
    print_endline (if Deck.Card.max card1 card3 = card1 then "card1" else "card3") ;
    print_string "max card3 card1 : " ;
    print_endline (if Deck.Card.max card3 card1 = card1 then "card1" else "card3") ;
    print_string "min card1 card2 : " ;
    print_endline (if Deck.Card.min card1 card2 = card1 then "card1" else "card2") ;
    print_string "min card2 card1 : " ;
    print_endline (if Deck.Card.min card2 card1 = card1 then "card1" else "card2") ;
    print_string "min card1 card3 : " ;
    print_endline (if Deck.Card.min card1 card3 = card1 then "card1" else "card3") ;
    print_string "min card3 card1 : " ;
    print_endline (if Deck.Card.min card3 card1 = card1 then "card1" else "card3") ;
    print_string "best of [card1;card2;card3] : " ;
    print_endline (let best = Deck.Card.best [card1;card2;card3] in if best = card1
    then "card1" else if best = card2 then "card2" else "card3") ;
    print_string "best of [card2;card3;card1] : " ;
    print_endline (let best = Deck.Card.best [card2;card3;card1] in if best = card1
    then "card1" else if best = card2 then "card2" else "card3") ;
    print_endline ("\ncard1 -> isOf Spade : " ^ (print_bool (Deck.Card.isOf
    card1 Deck.Card.Color.Spade)) ^ " ; isSpade : " ^ (print_bool
    (Deck.Card.isSpade card1)) ^ " ; isHeart : " ^ (print_bool (Deck.Card.isHeart card1)) ^ " ; isDiamond : " ^ (print_bool
    (Deck.Card.isDiamond card1)) ^ " ; isClub : " ^ (print_bool (Deck.Card.isClub card1)))
    ;
    print_endline ("card2 -> isOf Spade : " ^ (print_bool (Deck.Card.isOf
    card2 Deck.Card.Color.Spade)) ^ " ; isSpade : " ^ (print_bool
    (Deck.Card.isSpade card2)) ^ " ; isHeart : " ^ (print_bool (Deck.Card.isHeart card2)) ^ " ; isDiamond : " ^ (print_bool
    (Deck.Card.isDiamond card2)) ^ " ; isClub : " ^ (print_bool (Deck.Card.isClub card2)))
    ;
    print_endline ("card3 -> isOf Spade : " ^ (print_bool (Deck.Card.isOf
    card3 Deck.Card.Color.Spade)) ^ " ; isSpade : " ^ (print_bool
    (Deck.Card.isSpade card3)) ^ " ; isHeart : " ^ (print_bool (Deck.Card.isHeart card3)) ^ " ; isDiamond : " ^ (print_bool
    (Deck.Card.isDiamond card3)) ^ " ; isClub : " ^ (print_bool (Deck.Card.isClub card3)))

let print_deck deck func = 
    let rec print_d n = function
        | [] -> print_string ""
        | card::cards -> if n <> 0 then print_string ", " ; print_string card ; print_d (n + 1) cards
    in
    print_string "[" ;
    print_d 0 (func deck) ;
    print_string "]"

let draw_cards deck =
    print_string "\ndrawing cards from first deck until exception :\n" ;
    let rec drawz deck =
        let (x,xs) = Deck.drawCard deck in
        print_endline (Deck.Card.toStringVerbose x) ;
        drawz xs
    in
    drawz deck

let deck_test () =
    let deck1 = Deck.newDeck () in
    let deck2 = Deck.newDeck () in
    print_string "first  newDeck : " ;
    print_deck deck1 Deck.toStringList ;
    print_char '\n' ;
    print_string "second newDeck : " ;
    print_deck deck2 Deck.toStringList ;
    print_char '\n' ;
    print_string "first deck verbose : " ;
    print_deck deck1 Deck.toStringListVerbose ;
    print_char '\n' ;
    draw_cards deck1

let () =
    print_string "-- Deck.Card.Color test : \n" ;
    color_test () ;
    print_string "\n-- Deck.Card.Value test : \n" ;
    value_test () ;
    print_string "\n-- Deck.Card module test : \n" ;
    card_test () ;
    print_string "\n-- Deck module test : \n" ;
    deck_test () ;


let print_card_list cards func =
	let rec print_cards cards func n =
		if n = 0 then print_string "[" ;
		match cards with
			| [] -> print_string "]"
			| card::cards ->
				if n <> 0 then print_string ", " ;
				print_string (func card) ;
				print_cards cards func (n + 1)
	in
	print_cards cards func 0

let rm_first = function
	| [] -> []
	| x::xs -> xs

let rec rm_last = function
	| [] -> []
	| x::xs when xs = [] -> []
	| x::xs -> x::(rm_last xs)

let rec get_nexts = function
	| [] -> []
	| card::cards -> (Value.next card)::(get_nexts cards)

let rec get_previous = function
	| [] -> []
	| card::cards -> (Value.previous card)::(get_previous cards)

let () =
	let nexts = get_nexts (rm_last (Value.all)) in
	let previous = get_previous (rm_first (Value.all)) in
	print_string "all cards : " ;
	print_card_list (Value.all) Value.toString ;
	print_string "\nall cards verbose : " ;
	print_card_list (Value.all) Value.toStringVerbose ;
	print_string "\nall valid nexts : " ;
	print_card_list nexts Value.toString ;
	print_string "\nall valid previous : " ;
	print_card_list previous Value.toString ;
	print_char '\n'


type t = T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10 | Jack | Queen | King | As

let all = [T2;T3;T4;T5;T6;T7;T8;T9;T10;Jack;Queen;King;As]

let toInt = function
	| T2 -> 1
	| T3 -> 2
	| T4 -> 3
	| T5 -> 4
	| T6 -> 5
	| T7 -> 6
	| T8 -> 7
	| T9 -> 8
	| T10 -> 9
	| Jack -> 10
	| Queen -> 11
	| King -> 12
	| As -> 13

let toString = function
	| T2 -> "2"
	| T3 -> "3"
	| T4 -> "4"
	| T5 -> "5"
	| T6 -> "6"
	| T7 -> "7"
	| T8 -> "8"
	| T9 -> "9"
	| T10 -> "10"
	| Jack -> "J"
	| Queen -> "Q"
	| King -> "K"
	| As -> "A"

let toStringVerbose = function
	| T2 -> "2"
	| T3 -> "3"
	| T4 -> "4"
	| T5 -> "5"
	| T6 -> "6"
	| T7 -> "7"
	| T8 -> "8"
	| T9 -> "9"
	| T10 -> "10"
	| Jack -> "Jack"
	| Queen -> "Queen"
	| King -> "King"
	| As -> "As"

let next = function
	| T2 -> T3
	| T3 -> T4
	| T4 -> T5
	| T5 -> T6
	| T6 -> T7
	| T7 -> T8
	| T8 -> T9
	| T9 -> T10
	| T10 -> Jack
	| Jack -> Queen
	| Queen -> King
	| King -> As
	| As -> invalid_arg "As has no next card"

let previous = function
	| T2 -> invalid_arg "2 has no previous card"
	| T3 -> T2
	| T4 -> T3
	| T5 -> T4
	| T6 -> T5
	| T7 -> T6
	| T8 -> T7
	| T9 -> T8
	| T10 -> T9
	| Jack -> T10
	| Queen -> Jack
	| King -> Queen
	| As -> King


module Set =
struct

    type 'a t = Set of 'a list

    let return a = Set [a]

    let bind a func =
	    match a with
	    | Set lst ->
		    let rec _bind lst func =
			    match lst with
			    | [] -> []
			    | h::tl -> ((func h)::(_bind tl func))
		    in
		    Set (_bind lst func)

    let rec is_in_set vl set =
	    match set with
	    | [] -> false
	    | h::tl -> if h = vl then true else is_in_set vl tl

    let union set1 set2 =
	    let rec _union set1 set2 =
		    match set2 with
		    | [] -> set1
		    | h::tl ->	if is_in_set h set1
					    then _union set1 tl
					    else _union (h::set1) tl
	    in
	    match set1 with
	    | Set s1 -> begin
					    match set2 with
					    | Set s2 -> Set (_union s1 s2)
				    end

    let inter set1 set2 =
	    let rec _inter set1 set2 =
		    match set2 with
		    | [] -> []
		    | h::tl ->	if is_in_set h set1
					    then (h::(_inter set1 tl))
					    else _inter set1 tl
	    in
	    match set1 with
	    | Set s1 -> begin
					    match set2 with
					    | Set s2 -> Set (_inter s1 s2)
				    end

    let diff set1 set2 =
	    let rec _diff set1 set2 =
		    match set1 with
		    | [] -> []
		    | h::tl ->	if is_in_set h set2
					    then _diff tl set2
					    else (h::(_diff tl set2))
	    in
	    match set1 with
	    | Set s1 -> begin
					    match set2 with
					    | Set s2 -> Set (_diff s1 s2)
				    end

    let filter set cond =
	    let rec _filter set cond =
		    match set with
		    | [] -> []
		    | h::tl ->	if cond h
					    then (h::(_filter tl cond))
					    else _filter tl cond
	    in
	    match set with
	    | Set s -> Set (_filter s cond)

    let foreach set (func:'a -> unit) =
	    let rec exec set func =
		    match set with
		    | [] -> ignore ()
		    | h::tl -> (func h) ; exec tl func
	    in
	    match set with
	    | Set s -> exec s func

    let for_all set cond =
	    let rec _for_all set cond =
		    match set with
		    | [] -> true
		    | h::tl -> if cond h then _for_all tl cond else false
	    in
	    match set with
	    | Set s -> _for_all s cond

    let exists set cond =
	    let rec _exists set cond =
	    	match set with
		    | [] -> false
		    | h::tl -> if cond h then true else _exists tl cond
	    in
	    match set with
	    | Set s -> _exists s cond

end


let print_set set =
    let rec _print_set n = function
        | [] -> ignore ()
        | h::tl -> if n <> 0 then print_string ", " ; print_int h ; _print_set
        (n + 1) tl
    in
    print_string "Set (" ;
    ( match set with
    | My_set.Set.Set s -> _print_set 0 s ) ;
    print_char ')'

let print_set_string set =
    let rec _print_set n = function
        | [] -> ignore ()
        | h::tl -> if n <> 0 then print_string ", " ; print_char '"' ; print_string h ;
        print_string "\"" ; _print_set
        (n + 1) tl
    in
    print_string "Set (" ;
    ( match set with
    | My_set.Set.Set s -> _print_set 0 s ) ;
    print_char ')'

let print_bool = function
    | true -> print_string "true"
    | _ -> print_string "false"

let () =
    let set1 = My_set.Set.Set [5; 6; 1; 2; 3; 4; 9; 8; 0] in
    let set2 = My_set.Set.Set [13; 17; 18; 19; 25] in
    let set3 = My_set.Set.Set [13; 5; 6; 1; 2; 19; 119] in
    let set4 = My_set.Set.Set [] in
    let set5 = My_set.Set.bind set1 (fun x -> x + 2) in
    let set6 = My_set.Set.bind set1 (fun x -> string_of_int (x + 2)) in
    print_string "set1 = " ;
    print_set set1 ;
    print_char '\n' ;
    print_string "set2 = " ;
    print_set set2 ;
    print_char '\n' ;
    print_string "set3 = " ;
    print_set set3 ;
    print_char '\n' ;
    print_string "set4 (empty set) = " ;
    print_set set4 ;
    print_char '\n' ;
    print_string "\ncalling return on 10 : " ;
    print_set (My_set.Set.return 10) ;
    print_char '\n' ;
    print_string "calling bind set1 (fun x -> x + 2) : " ;
    print_set set5 ;
    print_char '\n' ;
    print_string "calling bind set1 (fun x -> string_of_int (x + 2)) : " ;
    print_set_string set6 ;
    print_char '\n' ;
    print_string "calling union on set1 set2 : " ;
    print_set (My_set.Set.union set1 set2) ;
    print_char '\n' ;
    print_string "calling union on set2 set3 : " ;
    print_set (My_set.Set.union set2 set3) ;
    print_char '\n' ;
    print_string "calling union on set3 set4 : " ;
    print_set (My_set.Set.union set3 set4) ;
    print_char '\n' ;
    print_string "calling inter on set1 set2 : " ;
    print_set (My_set.Set.inter set1 set2) ;
    print_char '\n' ;
    print_string "calling inter on set2 set3 : " ;
    print_set (My_set.Set.inter set2 set3) ;
    print_char '\n' ;
    print_string "calling inter on set3 set4 : " ;
    print_set (My_set.Set.inter set3 set4) ;
    print_char '\n' ;
    print_string "calling diff on set1 set2 : " ;
    print_set (My_set.Set.diff set1 set2) ;
    print_char '\n' ;
    print_string "calling diff on set2 set3 : " ;
    print_set (My_set.Set.diff set2 set3) ;
    print_char '\n' ;
    print_string "calling diff on set3 set2 : " ;
    print_set (My_set.Set.diff set3 set2) ;
    print_char '\n' ;
    print_string "calling diff on set3 set4 : " ;
    print_set (My_set.Set.diff set3 set4) ;
    print_char '\n' ;
    print_string "calling diff on set4 set2 : " ;
    print_set (My_set.Set.diff set4 set2) ;
    print_char '\n' ;
    print_string "calling filter set1 (fun x -> false) : " ;
    print_set (My_set.Set.filter set1 (fun x -> false)) ;
    print_char '\n' ;
    print_string "calling filter set1 (fun x -> true) : " ;
    print_set (My_set.Set.filter set1 (fun x -> true)) ;
    print_char '\n' ;
    print_string "calling filter set1 (fun x -> x > 7) : " ;
    print_set (My_set.Set.filter set1 (fun x -> x > 7)) ;
    print_char '\n' ;
    print_string "calling filter (union set1 set2) (fun x -> x > 7) : " ;
    print_set (My_set.Set.filter (My_set.Set.union set1 set2) (fun x -> x > 7)) ;
    print_char '\n' ;
    print_string "calling foreach set1 (fun x -> print_int x ; print_char '\\n') : " ;
    print_char '\n' ;
    My_set.Set.foreach set1 (fun x -> print_int x ; print_char '\n') ;
    print_string "calling for_all set1 (fun x -> x > 5) : " ;
    print_bool (My_set.Set.for_all set1 (fun x -> x > 5)) ;
    print_char '\n' ;
    print_string "calling for_all set1 (fun x -> x >= 0) : " ;
    print_bool (My_set.Set.for_all set1 (fun x -> x >= 0)) ;
    print_char '\n' ;
    print_string "calling for_all set4 (fun x -> true) : " ;
    print_bool (My_set.Set.for_all set4 (fun x -> true)) ;
    print_char '\n' ;
    print_string "calling exists set1 (fun x -> x > 9) : " ;
    print_bool (My_set.Set.exists set1 (fun x -> x > 9)) ;
    print_char '\n' ;
    print_string "calling exists set1 (fun x -> x > 8) : " ;
    print_bool (My_set.Set.exists set1 (fun x -> x > 8)) ;
    print_char '\n' ;
    print_string "calling exists set4 (fun x -> true) : " ;
    print_bool (My_set.Set.exists set4 (fun x -> true)) ;
    print_char '\n'


let print_hour n =
    print_string "printing hour : " ;
    print_int n ;
    print_char '\n'

let print_sub n m =
    print_string "sub " ;
    print_int n ;
    print_string " " ;
    print_int m ;
    print_string " : " ;
    print_int (Watchtower.sub n m) ;
    print_char '\n'

let print_add n m =
    print_string "add " ;
    print_int n ;
    print_string " " ;
    print_int m ;
    print_string " : " ;
    print_int (Watchtower.add n m) ;
    print_char '\n'

let () =
    let (hour1:Watchtower.hour) = 1 in
    let (hour2:Watchtower.hour) = 12 in
    let (hour3:Watchtower.hour) = 7 in
    let (hour4:Watchtower.hour) = 4 in
    let (hour5:Watchtower.hour) = 9 in
    let (hour6:Watchtower.hour) = 12 in
    let (hour7:Watchtower.hour) = 24 in
    print_hour hour1 ;
    print_hour hour2 ;
    print_hour hour3 ;
    print_hour hour4 ;
    print_sub hour1 hour2 ;
    print_sub hour2 hour1 ;
    print_sub hour3 hour4 ;
    print_sub hour4 hour3 ;
    print_sub hour5 hour4 ;
    print_sub hour5 hour6 ;
    print_sub hour5 hour7 ;
    print_sub hour6 hour5 ;
    print_sub 6 6 ;
    print_add hour1 hour2 ;
    print_add hour2 hour1 ;
    print_add hour3 hour4 ;
    print_add hour4 hour3 ;
    print_add hour5 hour4 ;
    print_add hour5 hour6 ;
    print_add hour5 hour7 ;
    print_add hour6 hour5 ;
    print_add 6 6


type hour = int
let zero:hour = 12
let add (a1:hour) (a2:hour) : hour =
    let res = (a1 + a2) mod zero in if res = 0 then zero else res
let sub (a1:hour) (a2:hour) : hour =
    let h = (a1 - a2) mod zero in if h < 0 then zero + h else (if h = 0 then 12
    else h )


module type MONOID =
sig
    type element
    val zero1 : element
    val zero2 : element
    val mul : element -> element -> element
    val add : element -> element -> element
    val div : element -> element -> element
    val sub : element -> element -> element
end

module Calc =
    functor (M : MONOID) ->
        struct
            let add = M.add
            let sub = M.sub
            let mul = M.mul
            let div = M.div
            let rec power a = function
                | n when n <= 0 -> M.zero2
                | n -> mul a (power a (n - 1))
            let rec fact = function
                | n when n <= M.zero1 -> M.zero2
                | n -> mul n (fact (sub n M.zero2))
        end

module INT : MONOID with type element = int =
struct
    type element = int
    let zero1 = 0
    let zero2 = 1
    let mul = ( * )
    let add = ( + )
    let div = ( / )
    let sub = ( - )
end

module FLOAT : MONOID with type element = float =
struct
    type element = float
    let zero1 = 0.0
    let zero2 = 1.0
    let mul = ( *. )
    let add = ( +. )
    let div = ( /. )
    let sub = ( -. )
end


module Calc_int = Arithmetic.Calc(Arithmetic.INT)
module Calc_float = Arithmetic.Calc(Arithmetic.FLOAT)

let () =
    print_endline (string_of_int (Calc_int.power 3 3));
    print_endline (string_of_float (Calc_float.power 3.0 3));
    print_endline (string_of_int (Calc_int.mul (Calc_int.add 20 1) 2));
    print_endline (string_of_float (Calc_float.mul (Calc_float.add 20.0 1.0)
    2.0)) ;
	print_string "power 3 0 : " ;
    print_endline (string_of_int (Calc_int.power 3 0)) ;
	print_string "power 3 1 : " ;
    print_endline (string_of_int (Calc_int.power 3 1)) ;
	print_string "power 3.0 0 : " ;
    print_endline (string_of_float (Calc_float.power 3.0 0)) ;
	print_string "power 3.0 1 : " ;
    print_endline (string_of_float (Calc_float.power 3.0 1)) ;
	print_string "fact 3 : " ;
    print_endline (string_of_int (Calc_int.fact 3)) ;
	print_string "fact 0 : " ;
    print_endline (string_of_int (Calc_int.fact 0)) ;
	print_string "fact 1 : " ;
    print_endline (string_of_int (Calc_int.fact 1)) ;
	print_string "fact 5 : " ;
    print_endline (string_of_int (Calc_int.fact 5)) ;
	print_string "fact 3.0 : " ;
    print_endline (string_of_float (Calc_float.fact 3.0)) ;
	print_string "fact 0.0 : " ;
    print_endline (string_of_float (Calc_float.fact 0.0)) ;
	print_string "fact 1.0 : " ;
    print_endline (string_of_float (Calc_float.fact 1.0)) ;
	print_string "fact 5.0 : " ;
    print_endline (string_of_float (Calc_float.fact 5.0)) ;
	print_string "fact 0.5 : " ;
	print_endline (string_of_float (Calc_float.fact 0.5)) ;
	print_string "fact 1.5 : " ;
	print_endline (string_of_float (Calc_float.fact 1.5)) ;
	print_string "fact 1.1 : " ;
	print_endline (string_of_float (Calc_float.fact 1.1))


type 'a t = Success of 'a | Failure of exn

let return a = Success a

let bind elt func =
	match elt with
	| Failure e -> Failure e
	| Success a -> 
		try func a with
		| e -> Failure e

let recover elt func =
	match elt with
	| Success _ -> elt
	| Failure e -> func e

let filter elt pred =
	match elt with
	| Failure _ -> elt
	| Success a when pred a -> elt
	| _ -> Failure (Failure "argument does not satisfy predicate")

let flatten (nest:'a t t) =
	match nest with
	| Success (Success a) -> Success a
	| Success (Failure e) -> Failure e
	| Failure e -> Failure e


let get_string_try = function
	| Try.Success a -> a ^ ""
	| _ -> ""

let print_failures = function
	| Try.Failure e -> print_string "Failure : \"" ; print_string (Printexc.to_string e) ; print_endline "\""
	| _ -> ignore ()

let print_try_int = function
	| Try.Success a ->  begin
							print_string "Success " ;
							print_int a ;
							print_char '\n'
						end
	| Try.Failure e -> print_failures (Try.Failure e)

let print_try_float = function
	| Try.Success a ->  begin
							print_string "Success " ;
							print_float a ;
							print_char '\n'
						end
	| Try.Failure e -> print_failures (Try.Failure e)

let print_try_string = function
	| Try.Success a ->  begin
							print_string "Success \"" ;
							print_string a ;
							print_endline "\""
						end
	| Try.Failure e -> print_failures (Try.Failure e)

let () =
	let a = Try.return "super" in
	let b = Try.return 21 in
	let c = Try.return 42.42 in
	let d = Try.Failure (Failure "failz") in
	let e = Try.return d in
	let f = Try.return (Try.Success 42) in
	let func1 = fun x -> Try.Success (x * 2) in
	let func2 = fun x -> Try.Success (x / 0) in
	let func3 = fun x -> Try.Success (x ^ "cool") in
	let func4 = fun x -> Try.Success "lolz" in
	let binded1 = Try.bind b func1 in
	let binded2 = Try.bind b func2 in
	let binded3 = Try.bind d func1 in
	let binded4 = Try.bind a func3 in
	let binded5 = Try.bind b func4 in
	let recov = fun e -> Try.Success 42 in
	print_endline "a = Success \"super\"" ;
	print_endline "b = Success 21" ;
	print_endline "c = Success 42.42" ;
	print_endline "d = Failure (Failure \"failz\")" ;
	print_endline "e = Success (Failure (Failure \"failz\"))" ;
	print_endline "f = Success (Success 42)" ;
	print_string "call bind a (fun x -> Success (x ^ \"cool\")) : " ;
	print_try_string binded4 ;
	print_string "call bind b (fun x -> Success (x * 2)) : " ;
	print_try_int binded1 ;
	print_string "call bind b (fun x -> Success (x / 0)) : " ;
	print_try_int binded2 ;
	print_string "call bind d (fun x -> Success (x * 2)) : " ;
	print_try_int binded3 ;
	print_string "call bind b (fun x -> Success \"lolz\") : " ;
	print_try_string binded5 ;
	print_string "call recover d (fun x -> Success 42) : " ;
	print_try_int (Try.recover d recov) ;
	print_string "call recover b (fun x -> Success 42) : " ;
	print_try_int (Try.recover b recov) ;
	print_string "call filter d (fun x -> false)) : " ;
	print_try_int (Try.filter d (fun x -> false)) ;
	print_string "call filter d (fun x -> true)) : " ;
	print_try_int (Try.filter d (fun x -> true)) ;
	print_string "call filter c (fun x -> false)) : " ;
	print_try_float (Try.filter c (fun x -> false)) ;
	print_string "call filter c (fun x -> true)) : " ;
	print_try_float (Try.filter c (fun x -> true)) ;
	print_string "call flatten f : " ;
	print_try_int (Try.flatten f) ;
	print_string "call flatten e : " ;
	print_try_int (Try.flatten e)


type project = string * string * int
let zero : project = ("","",0)
let combine ((n1,s1,g1):project) ((n2,s2,g2):project) : project = let av = (g1 + g2) / 2 in (n1 ^ n2, (if av > 80 then "succeed" else "failed"), av)
let fail ((n,s,g):project) : project = (n, "failed", 0)
let success ((n,s,g):project) : project = (n, "succeed", 80)


let print_proj (proj:App.project) =
    match proj with
    | (n,s,g) -> print_string "(name=" ; print_string n ; print_string " ; status=" ; print_string s ; print_string " ; grade=" ; print_int g ; print_string ")"

let () =
    let proj1:App.project = ("get_next_line", "failed", 32) in
    let proj2:App.project = ("fillit", "succeed", 87) in
    let proj3:App.project = ("piscine ocaml", "succeed", 126) in
    print_proj proj1 ;
    print_char '\n' ;
    print_proj proj2 ;
    print_char '\n' ;
    print_proj proj3 ;
    print_char '\n' ;
    print_string "calling fail on piscine ocaml : " ;
    print_proj (App.fail proj3) ;
    print_char '\n' ;
    print_string "calling success on get_next_line : " ;
    print_proj (App.success proj1) ;
    print_char '\n' ;
    print_string "combining get_next_line and piscine ocaml : " ;
    print_proj (App.combine proj1 proj3) ;
    print_char '\n' ;
    print_string "combining fillit and piscine ocaml : " ;
    print_proj (App.combine proj2 proj3) ;
    print_char '\n' ;
    print_string "zero project : " ;
    print_proj (App.zero) ;
    print_char '\n'


let rec parse tab str =
    let illegal tab =
        print_endline "Illegal move" ; get_input tab
    in
    let incorrect tab =
        print_endline "Incorrect format." ; get_input tab
    in
    let rec count_char str car ind acc =
        if String.length str <= ind then acc
        else
            let count = if String.get str ind = car then acc + 1
            else acc in
            count_char str car (ind + 1) count
    in
    let is_digit car = int_of_char car <= int_of_char '9' && int_of_char car
    >= int_of_char '0'
    in
    let rec only_digits str start en =
        if start >= en then true else
        let car = String.get str start in
        if is_digit car = false then false
        else only_digits str (start + 1) en
    in
    let rec ind str car from =
        let len = String.length str in
        if from >= len then (-1)
        else
            if String.get str from = car then from
            else ind str car (from + 1)
    in
    match (count_char str ' ' 0 0) with
        | 1 ->  let space_ind = ind str ' ' 0 in
                let len = String.length str in
                if space_ind < (len - 1) && space_ind > 0 && only_digits str 0
                space_ind && only_digits str (space_ind + 1) len
                then let str1 = String.sub str 0 space_ind in
                     let str2 = String.sub str (space_ind + 1) (len - space_ind - 1) in
                     if space_ind > 5 || (len - space_ind - 1) > 5 then illegal tab
                     else (int_of_string str1, int_of_string str2)
                else incorrect tab
        | _ -> incorrect tab

and get_input tab =
    let inp = read_line () in
    let (x,y) = parse tab inp in
    if Grid.is_in_bound tab (x,y) && Grid.get tab (x,y) = Grid.E then (x,y)
    else (print_endline "Illegal move" ; get_input tab)

let () =
    let tab = Grid.voidTab in
    let (x,y) = get_input tab in
    print_string "(x : " ;
    print_int x ;
    print_string ", y : " ;
    print_int y ;
    print_endline ")"


let rec power n x =
	match x with
		| x when x <= 0 -> 1
		| 1 -> n
		| _ -> n * (power n (x - 1))

let rec print_n_char car = function
	| n when n <= 0 -> ignore ()
	| n -> print_char car ; print_n_char car (n - 1)

let nb_chars_on_line line_width nb_sq =
	line_width * 2 + (((line_width / nb_sq) - 1) * 2)

let print_lines line_width nb_sq =
	let rec printl line_width nb_sq ind =
		if ind <> 0 && ind mod nb_sq = 0
		then print_string "| " ;
		print_string "- " ;
		if ind + 1< line_width
		then printl line_width nb_sq (ind + 1)
		else print_char '\n'
	in
	let rec printl_vert line_width nb_sq ind =
		if ind <> 0 && ind < line_width && ind mod nb_sq = 0
		then 	(let nb_dashes = nb_chars_on_line line_width nb_sq in
				print_n_char '-' nb_dashes ;
				print_char '\n' ) ;
		if ind < line_width
		then ( printl line_width nb_sq 0 ; printl_vert line_width nb_sq (ind + 1) )
		else print_char '\n'
	in
	printl_vert line_width nb_sq 0

let print_board depth nb_sq =
	let line_width = power nb_sq depth in
	print_lines line_width nb_sq

let () =
	let depth = 2 in
	let nb_sq = 3 in
	ignore (print_board depth nb_sq)


type t = O | X | E

let voidTab = X

let is_in_bound tab (x,y) =
    if x > 0 && x <= 9 && y > 0 && y <= 9
    then true
    else false

let get tab (x,y) =
    if x > 0 && x <= 9 && y > 0 && y <= 9
    then E
    else O


let width = 800
let height = 800
let repr = " 800x800"

let init () =
    Graphics.open_graph repr

let std_pencil () =
	Graphics.set_line_width 3

let large_pencil () =
	Graphics.set_line_width 5

let pick_color = function
	| n when n mod 5 = 0 -> Graphics.black
	| n when n mod 5 = 1 -> Graphics.black
	| n when n mod 5 = 2 -> Graphics.red
	| n when n mod 5 = 3 -> Graphics.blue
	| _ -> Graphics.cyan

let draw_rectangle x y w h =
	let up_l_x = x - (w / 2) in
	let up_l_y = y - (h / 2) in
	let up_r_x = x + (w / 2) in
	let up_r_y = y - (h / 2) in
	let lo_l_x = x - (w / 2) in
	let lo_l_y = y + (h / 2) in
	let lo_r_x = x + (w / 2) in
	let lo_r_y = y + (h / 2) in
	Graphics.moveto up_l_x up_l_y ;
	Graphics.lineto lo_l_x lo_l_y ;
	Graphics.moveto lo_l_x lo_l_y ;
	Graphics.lineto lo_r_x lo_r_y ;
	Graphics.moveto lo_r_x lo_r_y ;
	Graphics.lineto up_r_x up_r_y ;
	Graphics.moveto up_r_x up_r_y ;
	Graphics.lineto up_l_x up_l_y

let draw_square x y z =
	draw_rectangle x y z z

let draw_line x1 y1 x2 y2 =
	Graphics.moveto x1 y1 ;
	Graphics.lineto x2 y2

let rec draw_vert_line_of_sq n center_x center_y width =
	match n with
		| n when n > 0 -> 
			draw_square center_x center_y width ;
			draw_vert_line_of_sq (n - 1) center_x (center_y - width) width
		| _ -> ignore ()

let rec draw_hor_line_of_sq n center_x center_y width =
	match n with
		| n when n > 0 ->
			draw_square center_x center_y width ;
			draw_hor_line_of_sq (n - 1) (center_x + width) center_y width
		| _ -> ignore ()

let rec draw_n_squares n cent_x cent_y width =
	if n > 0 then
		let decal = width / 2 * n in
		let up_right_x = cent_x - decal in
		let up_right_y = cent_y + decal in
		let start_x = up_right_x + width / 2 in
		let start_y = up_right_y - width / 2 in
		let new_cent_x = cent_x + width / 2 in
		let new_cent_y = cent_y - width / 2 in
		draw_vert_line_of_sq n start_x start_y width ;
		draw_hor_line_of_sq n start_x start_y width ;
		draw_n_squares (n - 1) new_cent_x new_cent_y width

let rec power n x =
	match x with
		| x when x <= 0 -> 1
		| 1 -> n
		| _ -> n * (power n (x - 1))

let rec draw_borders depth nb_sq center_x center_y width ori_depth =
	if depth = 1 then std_pencil () else large_pencil () ;
	Graphics.set_color (pick_color depth);
	match depth with
		| n when n <= 0 || n > ori_depth -> ignore ()
		| _ ->  let nb_sq_to_draw = power nb_sq (ori_depth - depth + 1) in
				let pow_nb = (power nb_sq (depth - 1)) in
				draw_n_squares nb_sq_to_draw center_x center_y (width * pow_nb) ;
				draw_borders (depth + 1) nb_sq center_x center_y width ori_depth

let draw_n_n_squares depth nb_sq center_x center_y width =
	match depth with
		| n when n > 0 ->
			draw_borders 1 nb_sq center_x center_y width depth
		| _ -> ignore ()

let get_sq_width depth nb_sq =
	(width - width / 4) / (power nb_sq depth) / 4 * 4

let draw_tic_tac_toe depth nb_sq =
	let sq_width = get_sq_width depth nb_sq in
	draw_n_n_squares depth nb_sq (width / 2) (height / 2) sq_width

let get_click_coords () =
	let status = Graphics.wait_next_event [Graphics.Button_down] in
	(status.mouse_x, status.mouse_y)

let main_loop () =
	let mouse_coords = get_click_coords () in
	print_string "ok"

let launch depth nb_sq =
	init () ;
    draw_tic_tac_toe depth nb_sq ;
	main_loop ()

let () =
	launch 2 3


class trinitrotoluene =
object
    inherit Molecule.molecule "trinitrotoluene" [new Nitrogen.nitrogen ; new
    Hydrogen.hydrogen ; new Oxygen.oxygen ; new Carbon.carbon ; new
    Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ;
    new Carbon.carbon ; new Carbon.carbon ; new Oxygen.oxygen ; new
    Oxygen.oxygen ; new Oxygen.oxygen ; new Oxygen.oxygen ; new Oxygen.oxygen ;
    new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Nitrogen.nitrogen ; new Nitrogen.nitrogen]
end


class ethane =
object
    inherit Alkane.alkane 2
end


class helium =
object
    inherit Atom.atom "Helium" "He" 2
end


class virtual atom nam symbol numb =
object (self)
    val _name = nam
    val _symbol = symbol
    val _atomic_number = numb

    method name:string = _name
    method symbol:string = _symbol
    method atomic_number:int = _atomic_number
    method to_string = "Atom " ^ self#name ^ " : {symbol: " ^ self#symbol ^ " ; number : " ^ (string_of_int self#atomic_number) ^ "}"
    method equals (that:atom) = (that#name = self#name && that#symbol = self#symbol
                                && that#atomic_number = self#atomic_number)
    method greater_than (that:atom) =
        if self#atomic_number > that#atomic_number then true
        else false
    method greater_than_string (that:atom) =
        if self#symbol > that#symbol then true
        else false
end


class oxygen =
object
    inherit Atom.atom "Oxygen" "O" 8
end


class bohrium =
object
    inherit Atom.atom "Bohrium" "Bh" 107
end


class methane =
object
    inherit Alkane.alkane 1
end


class carbon_dioxyde =
object
    inherit Molecule.molecule "carbon dioxyde" [new Oxygen.oxygen ; new Carbon.carbon ;
    new Oxygen.oxygen]
end


class water =
object
    inherit Molecule.molecule "water" [new Oxygen.oxygen ; new Hydrogen.hydrogen ;
    new Hydrogen.hydrogen]
end


class virtual alkane n =
object
    inherit Molecule.molecule
                ((  match n with
                    | 1 -> "meth"
                    | 2 -> "eth"
                    | 3 -> "prop"
                    | 4 -> "but"
                    | 5 -> "pent"
                    | 6 -> "hex"
                    | 7 -> "hept"
                    | 8 -> "oct"
                    | 9 -> "non"
                    | 10 -> "dec"
                    | 11 -> "Undec"
                    | 12 -> "Dodec"
                    | n -> "tronched" ) ^ "ane") 

                ( let rec build_n n (acc:Atom.atom list) =
                    match n with
                    | 0 -> [new Hydrogen.hydrogen] @ [new Hydrogen.hydrogen] @ acc
                    | n -> build_n (n - 1) ([new Hydrogen.hydrogen] @ [new
                    Hydrogen.hydrogen] @ [new Carbon.carbon] @ acc)
                  in
                  build_n n [])
end


class carbon =
object
    inherit Atom.atom "Carbon" "C" 6
end


class alkane_combustion alkanes =
object
	inherit reaction alkanes

end


class sulphur =
object
    inherit Atom.atom "Sulphur" "S" 16
end


class yttrium =
object
    inherit Atom.atom "Yttrium" "Y" 39
end


class biotin =
object
    inherit Molecule.molecule "biotin" [new Sulphur.sulphur ; new Hydrogen.hydrogen
    ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ;
    new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Nitrogen.nitrogen ; new Nitrogen.nitrogen ; new Oxygen.oxygen ; new
    Oxygen.oxygen ; new Oxygen.oxygen ; new Carbon.carbon ; new Carbon.carbon ;
    new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new
    Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ;
    new Carbon.carbon]
end


class nitrogen =
object
    inherit Atom.atom "Nitrogen" "N" 7
end


class octane =
object
    inherit Alkane.alkane 8
end


class leucine =
object
    inherit Molecule.molecule "leucine" [new Oxygen.oxygen ; new Oxygen.oxygen ;
    new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Carbon.carbon ; new Carbon.carbon ; new
    Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ;
    new Nitrogen.nitrogen]
end


class virtual reaction mols1 =
object
	val _mols_in:Molecule.molecule list = mols1
	val _mols_out:Molecule.molecule list = []

    method virtual get_start: (Molecule.molecule * int) list
    method virtual get_result: (Molecule.molecule * int) list
    method virtual balance: reaction
    method virtual is_balanced: bool
end


let () =
	print_endline "It's just an interface, look up reaction.ml"


class hydrogen =
object
    inherit Atom.atom "Hydrogen" "H" 1
end


class virtual molecule name atoms =
object (self)
    val _name = name
    val _atoms = atoms

    method name:string = _name

    method private sort_atoms atoms =
        let atom_sort a1 a2 =
            let a1_val =
                begin
                    if a1#equals (new Carbon.carbon)
                    then 2
                    else
                        begin
                            if a1#equals (new Hydrogen.hydrogen)
                            then 1
                            else 0
                        end
                end
            in
            let a2_val =
                begin
                    if a2#equals (new Carbon.carbon)
                    then 2
                    else
                        begin
                            if a2#equals (new Hydrogen.hydrogen)
                            then 1
                            else 0
                        end
                end
            in
            if a1_val > 0 || a2_val > 0
            then
                if a1_val >= a2_val
                then (-1)
                else
                    if a1_val = a2_val
                    then 0
                    else 1
            else
                if a2#greater_than_string a1 then (-1)
                else if a1#equals a2 then 0
                else 1
        in
        List.sort atom_sort atoms

    method formula:string =
        let atoms = self#sort_atoms _atoms in
        let nb_atom_to_repr symb nb =
            if nb = 1 then symb
            else symb ^ (string_of_int nb)
        in
        let rec count_symbol current_symbol count = function
            | [] -> if count = 0 then "" else nb_atom_to_repr current_symbol count
            | h::tl when count = 0 || h#symbol = current_symbol -> count_symbol
            h#symbol (count + 1) tl
            | h::tl -> nb_atom_to_repr current_symbol count ^ (count_symbol
            h#symbol 1 tl)
        in
        count_symbol "a" 0 atoms

    method to_string:string = "Molecule " ^ self#name ^ " : " ^ self#formula

    method equals (that:molecule) = self#to_string = that#to_string
end


class cadmium =
object
    inherit Atom.atom "Cadmium" "Cd" 48
end


class helium =
object
    inherit Atom.atom "Helium" "He" 2
end


class virtual atom nam symbol numb =
object (self)
    val _name = nam
    val _symbol = symbol
    val _atomic_number = numb

    method name:string = _name
    method symbol:string = _symbol
    method atomic_number:int = _atomic_number
    method to_string = "Atom " ^ self#name ^ " : {symbol: " ^ self#symbol ^ " ; number : " ^ (string_of_int self#atomic_number) ^ "}"
    method equals (that:atom) = (that#name = self#name && that#symbol = self#symbol
                                && that#atomic_number = self#atomic_number)
    method greater_than (that:atom) =
        if self#atomic_number > that#atomic_number then true
        else false
    method greater_than_string (that:atom) =
        if self#symbol > that#symbol then true
        else false
end


class oxygen =
object
    inherit Atom.atom "Oxygen" "O" 8
end


class bohrium =
object
    inherit Atom.atom "Bohrium" "Bh" 107
end


class carbon =
object
    inherit Atom.atom "Carbon" "C" 6
end


class sulphur =
object
    inherit Atom.atom "Sulphur" "S" 16
end


class yttrium =
object
    inherit Atom.atom "Yttrium" "Y" 39
end


class nitrogen =
object
    inherit Atom.atom "Nitrogen" "N" 7
end


let print_testing atom =
    print_endline (atom#to_string)

let rec print_atoms = function
    | [] -> ignore ()
    | h::tl -> print_testing h ; print_atoms tl

let print_bool = function
    | true -> print_string "true"
    | _ -> print_string "false"

let () =
    let atoms = [
        new Bohrium.bohrium ;
        new Cadmium.cadmium ;
        new Carbon.carbon ;
        new Helium.helium ;
        new Hydrogen.hydrogen ;
        new Nitrogen.nitrogen ;
        new Oxygen.oxygen ;
        new Yttrium.yttrium ;
        new Sulphur.sulphur
    ] in
    print_atoms atoms ;
    let carbon1 = new Carbon.carbon in
    let carbon2 = new Carbon.carbon in
    let oxy = new Oxygen.oxygen in
    print_string "testing if carbon = carbon : " ;
    print_bool (carbon1#equals carbon2) ;
    print_string "\ntesting if carbon = oxygen : " ;
    print_bool (carbon1#equals oxy) ;
    print_char '\n'


class hydrogen =
object
    inherit Atom.atom "Hydrogen" "H" 1
end


class cadmium =
object
    inherit Atom.atom "Cadmium" "Cd" 48
end


class trinitrotoluene =
object
    inherit Molecule.molecule "trinitrotoluene" [new Nitrogen.nitrogen ; new
    Hydrogen.hydrogen ; new Oxygen.oxygen ; new Carbon.carbon ; new
    Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ;
    new Carbon.carbon ; new Carbon.carbon ; new Oxygen.oxygen ; new
    Oxygen.oxygen ; new Oxygen.oxygen ; new Oxygen.oxygen ; new Oxygen.oxygen ;
    new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Nitrogen.nitrogen ; new Nitrogen.nitrogen]
end


class ethane =
object
    inherit Alkane.alkane 2
end


class helium =
object
    inherit Atom.atom "Helium" "He" 2
end


class virtual atom nam symbol numb =
object (self)
    val _name = nam
    val _symbol = symbol
    val _atomic_number = numb

    method name:string = _name
    method symbol:string = _symbol
    method atomic_number:int = _atomic_number
    method to_string = "Atom " ^ self#name ^ " : {symbol: " ^ self#symbol ^ " ; number : " ^ (string_of_int self#atomic_number) ^ "}"
    method equals (that:atom) = (that#name = self#name && that#symbol = self#symbol
                                && that#atomic_number = self#atomic_number)
    method greater_than (that:atom) =
        if self#atomic_number > that#atomic_number then true
        else false
    method greater_than_string (that:atom) =
        if self#symbol > that#symbol then true
        else false
end


class oxygen =
object
    inherit Atom.atom "Oxygen" "O" 8
end


class bohrium =
object
    inherit Atom.atom "Bohrium" "Bh" 107
end


class methane =
object
    inherit Alkane.alkane 1
end


class carbon_dioxyde =
object
    inherit Molecule.molecule "carbon dioxyde" [new Oxygen.oxygen ; new Carbon.carbon ;
    new Oxygen.oxygen]
end


class water =
object
    inherit Molecule.molecule "water" [new Oxygen.oxygen ; new Hydrogen.hydrogen ;
    new Hydrogen.hydrogen]
end


class virtual alkane n =
object
    inherit Molecule.molecule
                ((  match n with
                    | 1 -> "meth"
                    | 2 -> "eth"
                    | 3 -> "prop"
                    | 4 -> "but"
                    | 5 -> "pent"
                    | 6 -> "hex"
                    | 7 -> "hept"
                    | 8 -> "oct"
                    | 9 -> "non"
                    | 10 -> "dec"
                    | 11 -> "Undec"
                    | 12 -> "Dodec"
                    | n -> "tronched" ) ^ "ane") 

                ( let rec build_n n (acc:Atom.atom list) =
                    match n with
                    | 0 -> [new Hydrogen.hydrogen] @ [new Hydrogen.hydrogen] @ acc
                    | n -> build_n (n - 1) ([new Hydrogen.hydrogen] @ [new
                    Hydrogen.hydrogen] @ [new Carbon.carbon] @ acc)
                  in
                  build_n n [])
end


class carbon =
object
    inherit Atom.atom "Carbon" "C" 6
end


class sulphur =
object
    inherit Atom.atom "Sulphur" "S" 16
end


class yttrium =
object
    inherit Atom.atom "Yttrium" "Y" 39
end


class biotin =
object
    inherit Molecule.molecule "biotin" [new Sulphur.sulphur ; new Hydrogen.hydrogen
    ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ;
    new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Nitrogen.nitrogen ; new Nitrogen.nitrogen ; new Oxygen.oxygen ; new
    Oxygen.oxygen ; new Oxygen.oxygen ; new Carbon.carbon ; new Carbon.carbon ;
    new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new
    Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ;
    new Carbon.carbon]
end


class nitrogen =
object
    inherit Atom.atom "Nitrogen" "N" 7
end


class octane =
object
    inherit Alkane.alkane 8
end


class leucine =
object
    inherit Molecule.molecule "leucine" [new Oxygen.oxygen ; new Oxygen.oxygen ;
    new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Carbon.carbon ; new Carbon.carbon ; new
    Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ;
    new Nitrogen.nitrogen]
end


let () =
    let methane = new Methane.methane in
    let ethane = new Ethane.ethane in
    let octane = new Octane.octane in
    print_endline methane#to_string ;
    print_endline ethane#to_string ;
    print_endline octane#to_string


class hydrogen =
object
    inherit Atom.atom "Hydrogen" "H" 1
end


class virtual molecule name atoms =
object (self)
    val _name = name
    val _atoms = atoms

    method name:string = _name

    method private sort_atoms atoms =
        let atom_sort a1 a2 =
            let a1_val =
                begin
                    if a1#equals (new Carbon.carbon)
                    then 2
                    else
                        begin
                            if a1#equals (new Hydrogen.hydrogen)
                            then 1
                            else 0
                        end
                end
            in
            let a2_val =
                begin
                    if a2#equals (new Carbon.carbon)
                    then 2
                    else
                        begin
                            if a2#equals (new Hydrogen.hydrogen)
                            then 1
                            else 0
                        end
                end
            in
            if a1_val > 0 || a2_val > 0
            then
                if a1_val >= a2_val
                then (-1)
                else
                    if a1_val = a2_val
                    then 0
                    else 1
            else
                if a2#greater_than_string a1 then (-1)
                else if a1#equals a2 then 0
                else 1
        in
        List.sort atom_sort atoms

    method formula:string =
        let atoms = self#sort_atoms _atoms in
        let nb_atom_to_repr symb nb =
            if nb = 1 then symb
            else symb ^ (string_of_int nb)
        in
        let rec count_symbol current_symbol count = function
            | [] -> if count = 0 then "" else nb_atom_to_repr current_symbol count
            | h::tl when count = 0 || h#symbol = current_symbol -> count_symbol
            h#symbol (count + 1) tl
            | h::tl -> nb_atom_to_repr current_symbol count ^ (count_symbol
            h#symbol 1 tl)
        in
        count_symbol "a" 0 atoms

    method to_string:string = "Molecule " ^ self#name ^ " : " ^ self#formula

    method equals (that:molecule) = self#to_string = that#to_string
end


class cadmium =
object
    inherit Atom.atom "Cadmium" "Cd" 48
end


class trinitrotoluene =
object
    inherit Molecule.molecule "trinitrotoluene" [new Nitrogen.nitrogen ; new
    Hydrogen.hydrogen ; new Oxygen.oxygen ; new Carbon.carbon ; new
    Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ;
    new Carbon.carbon ; new Carbon.carbon ; new Oxygen.oxygen ; new
    Oxygen.oxygen ; new Oxygen.oxygen ; new Oxygen.oxygen ; new Oxygen.oxygen ;
    new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Nitrogen.nitrogen ; new Nitrogen.nitrogen]
end


class ethane =
object
    inherit Alkane.alkane 2
end


class helium =
object
    inherit Atom.atom "Helium" "He" 2
end


class virtual atom nam symbol numb =
object (self)
    val _name = nam
    val _symbol = symbol
    val _atomic_number = numb

    method name:string = _name
    method symbol:string = _symbol
    method atomic_number:int = _atomic_number
    method to_string = "Atom " ^ self#name ^ " : {symbol: " ^ self#symbol ^ " ; number : " ^ (string_of_int self#atomic_number) ^ "}"
    method equals (that:atom) = (that#name = self#name && that#symbol = self#symbol
                                && that#atomic_number = self#atomic_number)
    method greater_than (that:atom) =
        if self#atomic_number > that#atomic_number then true
        else false
    method greater_than_string (that:atom) =
        if self#symbol > that#symbol then true
        else false
end


class oxygen =
object
    inherit Atom.atom "Oxygen" "O" 8
end


class bohrium =
object
    inherit Atom.atom "Bohrium" "Bh" 107
end


class methane =
object
    inherit Alkane.alkane 1
end


class carbon_dioxyde =
object
    inherit Molecule.molecule "carbon dioxyde" [new Oxygen.oxygen ; new Carbon.carbon ;
    new Oxygen.oxygen]
end


class water =
object
    inherit Molecule.molecule "water" [new Oxygen.oxygen ; new Hydrogen.hydrogen ;
    new Hydrogen.hydrogen]
end


class virtual alkane n =
object
    inherit Molecule.molecule
                ((  match n with
                    | 1 -> "meth"
                    | 2 -> "eth"
                    | 3 -> "prop"
                    | 4 -> "but"
                    | 5 -> "pent"
                    | 6 -> "hex"
                    | 7 -> "hept"
                    | 8 -> "oct"
                    | 9 -> "non"
                    | 10 -> "dec"
                    | 11 -> "Undec"
                    | 12 -> "Dodec"
                    | n -> "tronched" ) ^ "ane") 

                ( let rec build_n n (acc:Atom.atom list) =
                    match n with
                    | 0 -> [new Hydrogen.hydrogen] @ [new Hydrogen.hydrogen] @ acc
                    | n -> build_n (n - 1) ([new Hydrogen.hydrogen] @ [new
                    Hydrogen.hydrogen] @ [new Carbon.carbon] @ acc)
                  in
                  build_n n [])
end


class carbon =
object
    inherit Atom.atom "Carbon" "C" 6
end


class sulphur =
object
    inherit Atom.atom "Sulphur" "S" 16
end


class yttrium =
object
    inherit Atom.atom "Yttrium" "Y" 39
end


class biotin =
object
    inherit Molecule.molecule "biotin" [new Sulphur.sulphur ; new Hydrogen.hydrogen
    ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ;
    new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Nitrogen.nitrogen ; new Nitrogen.nitrogen ; new Oxygen.oxygen ; new
    Oxygen.oxygen ; new Oxygen.oxygen ; new Carbon.carbon ; new Carbon.carbon ;
    new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new
    Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ;
    new Carbon.carbon]
end


class nitrogen =
object
    inherit Atom.atom "Nitrogen" "N" 7
end


class octane =
object
    inherit Alkane.alkane 8
end


class leucine =
object
    inherit Molecule.molecule "leucine" [new Oxygen.oxygen ; new Oxygen.oxygen ;
    new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Carbon.carbon ; new Carbon.carbon ; new
    Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ;
    new Nitrogen.nitrogen]
end


class virtual reaction mols1 =
object
	val _mols_in:Molecule.molecule list = mols1
	val _mols_out:Molecule.molecule list = []

    method virtual get_start: (Molecule.molecule * int) list
    method virtual get_result: (Molecule.molecule * int) list
    method virtual balance: reaction
    method virtual is_balanced: bool
end


let () =
	print_endline "It's just an interface, look up reaction.ml"


class hydrogen =
object
    inherit Atom.atom "Hydrogen" "H" 1
end


class virtual molecule name atoms =
object (self)
    val _name = name
    val _atoms = atoms

    method name:string = _name

    method private sort_atoms atoms =
        let atom_sort a1 a2 =
            let a1_val =
                begin
                    if a1#equals (new Carbon.carbon)
                    then 2
                    else
                        begin
                            if a1#equals (new Hydrogen.hydrogen)
                            then 1
                            else 0
                        end
                end
            in
            let a2_val =
                begin
                    if a2#equals (new Carbon.carbon)
                    then 2
                    else
                        begin
                            if a2#equals (new Hydrogen.hydrogen)
                            then 1
                            else 0
                        end
                end
            in
            if a1_val > 0 || a2_val > 0
            then
                if a1_val >= a2_val
                then (-1)
                else
                    if a1_val = a2_val
                    then 0
                    else 1
            else
                if a2#greater_than_string a1 then (-1)
                else if a1#equals a2 then 0
                else 1
        in
        List.sort atom_sort atoms

    method formula:string =
        let atoms = self#sort_atoms _atoms in
        let nb_atom_to_repr symb nb =
            if nb = 1 then symb
            else symb ^ (string_of_int nb)
        in
        let rec count_symbol current_symbol count = function
            | [] -> if count = 0 then "" else nb_atom_to_repr current_symbol count
            | h::tl when count = 0 || h#symbol = current_symbol -> count_symbol
            h#symbol (count + 1) tl
            | h::tl -> nb_atom_to_repr current_symbol count ^ (count_symbol
            h#symbol 1 tl)
        in
        count_symbol "a" 0 atoms

    method to_string:string = "Molecule " ^ self#name ^ " : " ^ self#formula

    method equals (that:molecule) = self#to_string = that#to_string
end


class cadmium =
object
    inherit Atom.atom "Cadmium" "Cd" 48
end


class trinitrotoluene =
object
    inherit Molecule.molecule "trinitrotoluene" [new Nitrogen.nitrogen ; new
    Hydrogen.hydrogen ; new Oxygen.oxygen ; new Carbon.carbon ; new
    Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ;
    new Carbon.carbon ; new Carbon.carbon ; new Oxygen.oxygen ; new
    Oxygen.oxygen ; new Oxygen.oxygen ; new Oxygen.oxygen ; new Oxygen.oxygen ;
    new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Nitrogen.nitrogen ; new Nitrogen.nitrogen]
end


class helium =
object
    inherit Atom.atom "Helium" "He" 2
end


class virtual atom nam symbol numb =
object (self)
    val _name = nam
    val _symbol = symbol
    val _atomic_number = numb

    method name:string = _name
    method symbol:string = _symbol
    method atomic_number:int = _atomic_number
    method to_string = "Atom " ^ self#name ^ " : {symbol: " ^ self#symbol ^ " ; number : " ^ (string_of_int self#atomic_number) ^ "}"
    method equals (that:atom) = (that#name = self#name && that#symbol = self#symbol
                                && that#atomic_number = self#atomic_number)
    method greater_than (that:atom) =
        if self#atomic_number > that#atomic_number then true
        else false
    method greater_than_string (that:atom) =
        if self#symbol > that#symbol then true
        else false
end


class oxygen =
object
    inherit Atom.atom "Oxygen" "O" 8
end


class bohrium =
object
    inherit Atom.atom "Bohrium" "Bh" 107
end


class carbon_dioxyde =
object
    inherit Molecule.molecule "carbon dioxyde" [new Oxygen.oxygen ; new Carbon.carbon ;
    new Oxygen.oxygen]
end


class water =
object
    inherit Molecule.molecule "water" [new Oxygen.oxygen ; new Hydrogen.hydrogen ;
    new Hydrogen.hydrogen]
end


class carbon =
object
    inherit Atom.atom "Carbon" "C" 6
end


class sulphur =
object
    inherit Atom.atom "Sulphur" "S" 16
end


class yttrium =
object
    inherit Atom.atom "Yttrium" "Y" 39
end


class biotin =
object
    inherit Molecule.molecule "biotin" [new Sulphur.sulphur ; new Hydrogen.hydrogen
    ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ;
    new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Nitrogen.nitrogen ; new Nitrogen.nitrogen ; new Oxygen.oxygen ; new
    Oxygen.oxygen ; new Oxygen.oxygen ; new Carbon.carbon ; new Carbon.carbon ;
    new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new
    Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ;
    new Carbon.carbon]
end


class nitrogen =
object
    inherit Atom.atom "Nitrogen" "N" 7
end


class leucine =
object
    inherit Molecule.molecule "leucine" [new Oxygen.oxygen ; new Oxygen.oxygen ;
    new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new Hydrogen.hydrogen ; new
    Hydrogen.hydrogen ; new Carbon.carbon ; new Carbon.carbon ; new
    Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ; new Carbon.carbon ;
    new Nitrogen.nitrogen]
end


let print_bool = function
    | true -> print_string "true"
    | _ -> print_string "false"

let () =
    let carbon_dioxyde = new Carbon_dioxyde.carbon_dioxyde in
    let water = new Water.water in
    let tnt = new Trinitrotoluene.trinitrotoluene in
    let biotin = new Biotin.biotin in
    let leucine = new Leucine.leucine in
    print_endline carbon_dioxyde#to_string ;
    print_endline water#to_string ;
    print_endline tnt#to_string ;
    print_endline biotin#to_string ;
    print_endline leucine#to_string ;
    print_string "is carbon_dioxyde = water : " ;
    print_bool (carbon_dioxyde#equals water) ;
    print_string "\nis water = water : " ;
    print_bool (water#equals water) ;
    print_char '\n' 


class hydrogen =
object
    inherit Atom.atom "Hydrogen" "H" 1
end


class virtual molecule name atoms =
object (self)
    val _name = name
    val _atoms = atoms

    method name:string = _name

    method private sort_atoms atoms =
        let atom_sort a1 a2 =
            let a1_val =
                begin
                    if a1#equals (new Carbon.carbon)
                    then 2
                    else
                        begin
                            if a1#equals (new Hydrogen.hydrogen)
                            then 1
                            else 0
                        end
                end
            in
            let a2_val =
                begin
                    if a2#equals (new Carbon.carbon)
                    then 2
                    else
                        begin
                            if a2#equals (new Hydrogen.hydrogen)
                            then 1
                            else 0
                        end
                end
            in
            if a1_val > 0 || a2_val > 0
            then
                if a1_val >= a2_val
                then (-1)
                else
                    if a1_val = a2_val
                    then 0
                    else 1
            else
                if a2#greater_than_string a1 then (-1)
                else if a1#equals a2 then 0
                else 1
        in
        List.sort atom_sort atoms

    method formula:string =
        let atoms = self#sort_atoms _atoms in
        let nb_atom_to_repr symb nb =
            if nb = 1 then symb
            else symb ^ (string_of_int nb)
        in
        let rec count_symbol current_symbol count = function
            | [] -> if count = 0 then "" else nb_atom_to_repr current_symbol count
            | h::tl when count = 0 || h#symbol = current_symbol -> count_symbol
            h#symbol (count + 1) tl
            | h::tl -> nb_atom_to_repr current_symbol count ^ (count_symbol
            h#symbol 1 tl)
        in
        count_symbol "a" 0 atoms

    method to_string:string = "Molecule " ^ self#name ^ " : " ^ self#formula

    method equals (that:molecule) = self#to_string = that#to_string
end


class cadmium =
object
    inherit Atom.atom "Cadmium" "Cd" 48
end


module type VAL =
sig
    type t
    val add : t -> t -> t
    val mul : t -> t -> t
end

module IntVal : VAL with type t = int =
struct
    type t = int
    let add = ( + )
    let mul = ( * )
end

module FloatVal : VAL with type t = float =
struct
    type t = float
    let add = ( +. )
    let mul = ( *. )
end

module StringVal : VAL with type t = string =
struct
    type t = string
    let add s1 s2 = if (String.length s1) > (String.length s2) then s1 else s2
    let mul = ( ^ )
end

module type EVALEXPR =
sig
    type t
    type expr = Value of t | Add of expr * expr | Mul of expr * expr

    val eval : expr -> t
end

module type MAKEEVALEXPR =
    functor (Val : VAL) ->
        EVALEXPR with type t = Val.t

module MakeEvalExpr : MAKEEVALEXPR =
    functor (Val : VAL) ->
        struct
            type t = Val.t
            type expr = Value of t | Add of expr * expr | Mul of expr * expr
        
            let rec eval = function
                | Add (a,b) -> Val.add (eval a) (eval b)
                | Mul (a,b) -> Val.mul (eval a) (eval b)
                | Value v -> v
        end

module IntEvalExpr : (EVALEXPR with type t = IntVal.t) = MakeEvalExpr (IntVal)
module FloatEvalExpr : (EVALEXPR with type t = FloatVal.t) = MakeEvalExpr (FloatVal)
module StringEvalExpr : (EVALEXPR with type t = StringVal.t) = MakeEvalExpr (StringVal)

let ie = IntEvalExpr.Add (IntEvalExpr.Value 40, IntEvalExpr.Value 2)
let fe = FloatEvalExpr.Add (FloatEvalExpr.Value 41.5, FloatEvalExpr.Value 0.92)
let se = StringEvalExpr.Mul (StringEvalExpr.Value "very ",
(StringEvalExpr.Add (StringEvalExpr.Value "very long",
StringEvalExpr.Value "short")))

let () = Printf.printf "Res = %d\n" (IntEvalExpr.eval ie)
let () = Printf.printf "Res = %f\n" (FloatEvalExpr.eval fe)
let () = Printf.printf "Res = %s\n" (StringEvalExpr.eval se)


module StringSet = Set.Make(String)

let () =
    let set = List.fold_right StringSet.add [ "foo"; "bar"; "baz"; "qux" ]
    StringSet.empty in
    StringSet.iter print_endline set;
    print_endline (StringSet.fold ( ^ ) set "")
    
module type PAIR = sig val pair : (int * int) end
module type VAL = sig val x : int end

module Pair : PAIR = struct let pair = ( 21, 42 ) end

module type MAKEPROJECTION =
    functor (Pair : PAIR) ->
        sig
            val x : int
        end 

module MakeFst : MAKEPROJECTION =
    functor (Pair : PAIR) ->
        struct
            let x = fst Pair.pair
        end

module MakeSnd : MAKEPROJECTION =
    functor (Pair : PAIR) ->
        struct
            let x = snd Pair.pair
        end

module Fst : VAL = MakeFst (Pair)
module Snd : VAL = MakeSnd (Pair)


let () = Printf.printf "Fst.x = %d, Snd.x = %d\n" Fst.x Snd.x


module type FRACTIONNAL_BITS =
    sig
        val bits : int
    end

module type FIXED = sig
    type t
    val of_float : float -> t
    val of_int : int -> t
    val to_float : t -> float
    val to_int : t -> int
    val to_string : t -> string
    val zero : t
    val one : t
    val succ : t -> t
    val pred : t -> t
    val min : t -> t -> t
    val max : t -> t -> t
    val gth : t -> t -> bool
    val lth : t -> t -> bool
    val gte : t -> t -> bool
    val lte : t -> t -> bool
    val eqp : t -> t -> bool (** physical equality *)
    val eqs : t -> t -> bool (** structural equality *)
    val add : t -> t -> t
    val sub : t -> t -> t
    val mul : t -> t -> t
    val div : t -> t -> t
    val foreach : t -> t -> (t -> unit) -> unit
end

module type MAKE =
    functor (Frac : FRACTIONNAL_BITS) ->
        FIXED

module Make : MAKE =
    functor (Frac : FRACTIONNAL_BITS) ->
        struct
            type t = int

            let of_float i =
                let round v = if (ceil v) -. v < v -. (floor v) then ceil v else floor v in
                int_of_float (round (i *. (float_of_int (1 lsl Frac.bits))))
            let of_int i = i lsl Frac.bits
            let to_float e = (float_of_int e) /. float_of_int (1 lsl Frac.bits)
            let to_int e = e lsl Frac.bits
            let to_string e = string_of_float (to_float e)
            let zero = 0
            let one = of_int 1
            let succ e = e + 1
            let pred e = e - 1
            let min e1 e2 = if e1 <= e2 then e1 else e2
            let max e1 e2 = if e1 >= e2 then e1 else e2
            let gth e1 e2 = e1 > e2
            let lth e1 e2 = e1 < e2
            let gte e1 e2 = e1 >= e2
            let lte e1 e2 = e1 <= e2
            let eqp e1 e2 = e1 = e2
            let eqs e1 e2 = e1 == e2
            let add e1 e2 = e1 + e2
            let sub e1 e2 = e1 - e2
            let mul e1 e2 = (e1 * e2 + (1 lsl (Frac.bits - 1))) lsr Frac.bits
            let div e1 e2 = ((e1 lsl Frac.bits) + (e2 / 2)) / e2
            let rec foreach e1 e2 func = if lte e1 e2 then (func e1 ; foreach (succ e1) e2 func)
        end

module Fixed4 : FIXED = Make (struct let bits = 4 end)
module Fixed8 : FIXED = Make (struct let bits = 8 end)
let () =
    let x8 = Fixed8.of_float 21.10 in
    let y8 = Fixed8.of_float 21.32 in
    let r8 = Fixed8.add x8 y8 in
    print_endline (Fixed8.to_string r8);
    Fixed4.foreach (Fixed4.zero) (Fixed4.one) (fun f -> print_endline
    (Fixed4.to_string f))


module StringHash =
    struct
        type t = string

        let hash str =
            let rec _hash str ind acc =
                match ind with
                | n when n >= String.length str -> acc
                | n -> _hash str (ind + 1) (acc * 33 + int_of_char (String.get str ind))
            in
            _hash str 0 5381

        let equal str1 str2 =
            str1 = str2
    end

module StringHashtbl = Hashtbl.Make (StringHash)

let () =
    let ht = StringHashtbl.create 5 in
    let values = [ "Hello"; "world"; "42"; "Ocaml"; "H" ] in
    let pairs = List.map (fun s -> (s, String.length s)) values in
    List.iter (fun (k,v) -> StringHashtbl.add ht k v) pairs;
    StringHashtbl.iter (fun k v -> Printf.printf "k = \"%s\", v = %d\n" k v) ht
